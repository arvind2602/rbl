"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked";
exports.ids = ["vendor-chunks/marked"];
exports.modules = {

/***/ "(ssr)/./node_modules/marked/lib/marked.cjs":
/*!********************************************!*\
  !*** ./node_modules/marked/lib/marked.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * marked v4.3.0 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ \nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction getDefaults() {\n    return {\n        async: false,\n        baseUrl: null,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: \"\",\n        highlight: null,\n        hooks: null,\n        langPrefix: \"language-\",\n        mangle: true,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n    };\n}\nexports.defaults = getDefaults();\nfunction changeDefaults(newDefaults) {\n    exports.defaults = newDefaults;\n}\n/**\n * Helpers\n */ var escapeTest = /[&<>\"']/;\nvar escapeReplace = new RegExp(escapeTest.source, \"g\");\nvar escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nvar escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nvar escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nvar getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n};\nfunction escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nvar unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n/**\n * @param {string} html\n */ function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function(_, n) {\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nvar caret = /(^|[^\\[])\\^/g;\n/**\n * @param {string | RegExp} regex\n * @param {string} opt\n */ function edit(regex, opt) {\n    regex = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    var obj = {\n        replace: function replace(name, val) {\n            val = val.source || val;\n            val = val.replace(caret, \"$1\");\n            regex = regex.replace(name, val);\n            return obj;\n        },\n        getRegex: function getRegex() {\n            return new RegExp(regex, opt);\n        }\n    };\n    return obj;\n}\nvar nonWordAndColonTest = /[^\\w:]/g;\nvar originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n/**\n * @param {boolean} sanitize\n * @param {string} base\n * @param {string} href\n */ function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n        var prot;\n        try {\n            prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, \"\").toLowerCase();\n        } catch (e) {\n            return null;\n        }\n        if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n            return null;\n        }\n    }\n    if (base && !originIndependentUrl.test(href)) {\n        href = resolveUrl(base, href);\n    }\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nvar baseUrls = {};\nvar justDomain = /^[^:]+:\\/*[^/]*$/;\nvar protocol = /^([^:]+:)[\\s\\S]*$/;\nvar domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n/**\n * @param {string} base\n * @param {string} href\n */ function resolveUrl(base, href) {\n    if (!baseUrls[\" \" + base]) {\n        // we can ignore everything in base after the last slash of its path component,\n        // but we might need to add _that_\n        // https://tools.ietf.org/html/rfc3986#section-3\n        if (justDomain.test(base)) {\n            baseUrls[\" \" + base] = base + \"/\";\n        } else {\n            baseUrls[\" \" + base] = rtrim(base, \"/\", true);\n        }\n    }\n    base = baseUrls[\" \" + base];\n    var relativeBase = base.indexOf(\":\") === -1;\n    if (href.substring(0, 2) === \"//\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(protocol, \"$1\") + href;\n    } else if (href.charAt(0) === \"/\") {\n        if (relativeBase) {\n            return href;\n        }\n        return base.replace(domain, \"$1\") + href;\n    } else {\n        return base + href;\n    }\n}\nvar noopTest = {\n    exec: function noopTest() {}\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function(match, offset, str) {\n        var escaped = false, curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\"){\n            escaped = !escaped;\n        }\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    var i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (cells.length > count) {\n        cells.splice(count);\n    } else {\n        while(cells.length < count){\n            cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param {string} str\n * @param {string} c\n * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    var l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    var suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        var currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    var l = str.length;\n    var level = 0, i = 0;\n    for(; i < l; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n        console.warn(\"marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options\");\n    }\n}\n// copied from https://stackoverflow.com/a/5450113/806777\n/**\n * @param {string} pattern\n * @param {number} count\n */ function repeatString(pattern, count) {\n    if (count < 1) {\n        return \"\";\n    }\n    var result = \"\";\n    while(count > 1){\n        if (count & 1) {\n            result += pattern;\n        }\n        count >>= 1;\n        pattern += pattern;\n    }\n    return result + pattern;\n}\nfunction outputLink(cap, link, raw, lexer) {\n    var href = link.href;\n    var title = link.title ? escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        var token = {\n            type: \"link\",\n            raw: raw,\n            href: href,\n            title: title,\n            text: text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw: raw,\n        href: href,\n        title: title,\n        text: escape(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    var indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map(function(node) {\n        var matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        var indentInNode = matchIndentInNode[0];\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ var Tokenizer = /*#__PURE__*/ function() {\n    function Tokenizer(options) {\n        this.options = options || exports.defaults;\n    }\n    var _proto = Tokenizer.prototype;\n    _proto.space = function space(src) {\n        var cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    };\n    _proto.code = function code(src) {\n        var cap = this.rules.block.code.exec(src);\n        if (cap) {\n            var text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    };\n    _proto.fences = function fences(src) {\n        var cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            var raw = cap[0];\n            var text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw: raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, \"$1\") : cap[2],\n                text: text\n            };\n        }\n    };\n    _proto.heading = function heading(src) {\n        var cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            var text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                var trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text: text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    };\n    _proto.hr = function hr(src) {\n        var cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    };\n    _proto.blockquote = function blockquote(src) {\n        var cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            var text = cap[0].replace(/^ *>[ \\t]?/gm, \"\");\n            var top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            var tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens: tokens,\n                text: text\n            };\n        }\n    };\n    _proto.list = function list(src) {\n        var cap = this.rules.block.list.exec(src);\n        if (cap) {\n            var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;\n            var bull = cap[1].trim();\n            var isordered = bull.length > 1;\n            var list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? \"\\\\d{1,9}\\\\\" + bull.slice(-1) : \"\\\\\" + bull;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            var itemRegex = new RegExp(\"^( {0,3}\" + bull + \")((?:[\t ][^\\\\n]*)?(?:\\\\n|$))\");\n            // Check if current bullet point can start a new List Item\n            while(src){\n                endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, function(t) {\n                    return \" \".repeat(3 * t.length);\n                });\n                nextLine = src.split(\"\\n\", 1)[0];\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimLeft();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    // Items begin with at most one blank line\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    var nextBulletRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \t][^\\\\n]*)?(?:\\\\n|$))\");\n                    var hrRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)\");\n                    var fencesBeginRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:```|~~~)\");\n                    var headingBeginRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}#\");\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            // Dedent if possible\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw: raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimRight();\n            list.items[list.items.length - 1].text = itemContents.trimRight();\n            list.raw = list.raw.trimRight();\n            var l = list.items.length;\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(i = 0; i < l; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    var spacers = list.items[i].tokens.filter(function(t) {\n                        return t.type === \"space\";\n                    });\n                    var hasMultipleLineBreaks = spacers.length > 0 && spacers.some(function(t) {\n                        return /\\n.*\\n/.test(t.raw);\n                    });\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(i = 0; i < l; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    };\n    _proto.html = function html(src) {\n        var cap = this.rules.block.html.exec(src);\n        if (cap) {\n            var token = {\n                type: \"html\",\n                raw: cap[0],\n                pre: !this.options.sanitizer && (cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\"),\n                text: cap[0]\n            };\n            if (this.options.sanitize) {\n                var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n                token.type = \"paragraph\";\n                token.text = text;\n                token.tokens = this.lexer.inline(text);\n            }\n            return token;\n        }\n    };\n    _proto.def = function def(src) {\n        var cap = this.rules.block.def.exec(src);\n        if (cap) {\n            var tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            var href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline._escapes, \"$1\") : \"\";\n            var title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag: tag,\n                raw: cap[0],\n                href: href,\n                title: title\n            };\n        }\n    };\n    _proto.table = function table(src) {\n        var cap = this.rules.block.table.exec(src);\n        if (cap) {\n            var item = {\n                type: \"table\",\n                header: splitCells(cap[1]).map(function(c) {\n                    return {\n                        text: c\n                    };\n                }),\n                align: cap[2].replace(/^ *|\\| *$/g, \"\").split(/ *\\| */),\n                rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : []\n            };\n            if (item.header.length === item.align.length) {\n                item.raw = cap[0];\n                var l = item.align.length;\n                var i, j, k, row;\n                for(i = 0; i < l; i++){\n                    if (/^ *-+: *$/.test(item.align[i])) {\n                        item.align[i] = \"right\";\n                    } else if (/^ *:-+: *$/.test(item.align[i])) {\n                        item.align[i] = \"center\";\n                    } else if (/^ *:-+ *$/.test(item.align[i])) {\n                        item.align[i] = \"left\";\n                    } else {\n                        item.align[i] = null;\n                    }\n                }\n                l = item.rows.length;\n                for(i = 0; i < l; i++){\n                    item.rows[i] = splitCells(item.rows[i], item.header.length).map(function(c) {\n                        return {\n                            text: c\n                        };\n                    });\n                }\n                // parse child tokens inside headers and cells\n                // header child tokens\n                l = item.header.length;\n                for(j = 0; j < l; j++){\n                    item.header[j].tokens = this.lexer.inline(item.header[j].text);\n                }\n                // cell child tokens\n                l = item.rows.length;\n                for(j = 0; j < l; j++){\n                    row = item.rows[j];\n                    for(k = 0; k < row.length; k++){\n                        row[k].tokens = this.lexer.inline(row[k].text);\n                    }\n                }\n                return item;\n            }\n        }\n    };\n    _proto.lheading = function lheading(src) {\n        var cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    };\n    _proto.paragraph = function paragraph(src) {\n        var cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            var text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text: text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    };\n    _proto.text = function text(src) {\n        var cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    };\n    _proto.escape = function escape$1(src) {\n        var cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape(cap[1])\n            };\n        }\n    };\n    _proto.tag = function tag(src) {\n        var cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: this.options.sanitize ? \"text\" : \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n            };\n        }\n    };\n    _proto.link = function link(src) {\n        var cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            var trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                var lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    var start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    var linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            var href = cap[2];\n            var title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline._escapes, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline._escapes, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    };\n    _proto.reflink = function reflink(src, links) {\n        var cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            var link = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            link = links[link.toLowerCase()];\n            if (!link) {\n                var text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text: text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    };\n    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {\n        if (prevChar === void 0) {\n            prevChar = \"\";\n        }\n        var match = this.rules.inline.emStrong.lDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/(?:[0-9A-Za-z\\xAA\\xB2\\xB3\\xB5\\xB9\\xBA\\xBC-\\xBE\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE1-\\uDEFB\\uDF00-\\uDF23\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC58-\\uDC76\\uDC79-\\uDC9E\\uDCA7-\\uDCAF\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDCFB-\\uDD1B\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBC-\\uDDCF\\uDDD2-\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE40-\\uDE48\\uDE60-\\uDE7E\\uDE80-\\uDE9F\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDEEB-\\uDEEF\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF58-\\uDF72\\uDF78-\\uDF91\\uDFA9-\\uDFAF]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDCFA-\\uDD23\\uDD30-\\uDD39\\uDE60-\\uDE7E\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF27\\uDF30-\\uDF45\\uDF51-\\uDF54\\uDF70-\\uDF81\\uDFB0-\\uDFCB\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC52-\\uDC6F\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD03-\\uDD26\\uDD36-\\uDD3F\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDD0-\\uDDDA\\uDDDC\\uDDE1-\\uDDF4\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDEF0-\\uDEF9\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC50-\\uDC59\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEAA\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF30-\\uDF3B\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCF2\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC50-\\uDC6C\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF2\\uDFB0\\uDFC0-\\uDFD4]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF5B-\\uDF61\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE96\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD834[\\uDEE0-\\uDEF3\\uDF60-\\uDF78]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB\\uDEF0-\\uDEF9]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCC7-\\uDCCF\\uDD00-\\uDD43\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDC71-\\uDCAB\\uDCAD-\\uDCAF\\uDCB1-\\uDCB4\\uDD01-\\uDD2D\\uDD2F-\\uDD3D\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD00-\\uDD0C]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/)) return;\n        var nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || nextChar && (prevChar === \"\" || this.rules.inline.punctuation.exec(prevChar))) {\n            var lLength = match[0].length - 1;\n            var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            var endReg = match[0][0] === \"*\" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = rDelim.length;\n                if (match[3] || match[4]) {\n                    // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                var raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    var _text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw: raw,\n                        text: _text,\n                        tokens: this.lexer.inlineTokens(_text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                var text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw: raw,\n                    text: text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    };\n    _proto.codespan = function codespan(src) {\n        var cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            var text = cap[2].replace(/\\n/g, \" \");\n            var hasNonSpaceChars = /[^ ]/.test(text);\n            var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text: text\n            };\n        }\n    };\n    _proto.br = function br(src) {\n        var cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    };\n    _proto.del = function del(src) {\n        var cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    };\n    _proto.autolink = function autolink(src, mangle) {\n        var cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            var text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text: text,\n                href: href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text: text\n                    }\n                ]\n            };\n        }\n    };\n    _proto.url = function url(src, mangle) {\n        var cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            var text, href;\n            if (cap[2] === \"@\") {\n                text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                var prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n                }while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text: text,\n                href: href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text: text\n                    }\n                ]\n            };\n        }\n    };\n    _proto.inlineText = function inlineText(src, smartypants) {\n        var cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            var text;\n            if (this.lexer.state.inRawBlock) {\n                text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n            } else {\n                text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: text\n            };\n        }\n    };\n    return Tokenizer;\n}();\n/**\n * Block-Level Grammar\n */ var block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n    html: \"^ {0,3}(?:\" // optional indentation\n     + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n     + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n     + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n     + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n     + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n     + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n     + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n     + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n     + \")\",\n    def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^((?:.|\\n(?!\\n))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n};\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def).replace(\"label\", block._label).replace(\"title\", block._title).getRegex();\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */).replace(\"bull\", block.bullet).getRegex();\nblock.list = edit(block.list).replace(/bull/g, block.bullet).replace(\"hr\", \"\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))\").replace(\"def\", \"\\\\n+(?=\" + block.def.source + \")\").getRegex();\nblock._tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, \"i\").replace(\"comment\", block._comment).replace(\"tag\", block._tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nblock.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nblock.blockquote = edit(block.blockquote).replace(\"paragraph\", block.paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ block.normal = _extends({}, block);\n/**\n * GFM Block Grammar\n */ block.gfm = _extends({}, block.normal, {\n    table: \"^ *([^\\\\n ].*\\\\|.*)\\\\n\" // Header\n     + \" {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?\" // Align\n     + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\" // Cells\n});\nblock.gfm.table = edit(block.gfm.table).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nblock.gfm.paragraph = edit(block._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" {0,3}#{1,6} \").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"table\", block.gfm.table) // interrupt paragraphs with table\n.replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", block._tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ block.pedantic = _extends({}, block.normal, {\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", block._comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(block.normal._paragraph).replace(\"hr\", block.hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", block.lheading).replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").getRegex()\n});\n/**\n * Inline-Level Grammar\n */ var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: \"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n     + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n     + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n     + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n     + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\",\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n    nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n    reflinkSearch: \"reflink|nolink(?!\\\\()\",\n    emStrong: {\n        lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n        //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n        rDelimAst: /^(?:[^_*\\\\]|\\\\.)*?\\_\\_(?:[^_*\\\\]|\\\\.)*?\\*(?:[^_*\\\\]|\\\\.)*?(?=\\_\\_)|(?:[^*\\\\]|\\\\.)+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[^punct*_\\s])/,\n        rDelimUnd: /^(?:[^_*\\\\]|\\\\.)*?\\*\\*(?:[^_*\\\\]|\\\\.)*?\\_(?:[^_*\\\\]|\\\\.)*?(?=\\*\\*)|(?:[^_\\\\]|\\\\.)+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\spunctuation])/\n};\n// list of punctuation marks from CommonMark spec\n// without * and _ to handle the different emphasis markers * and _\ninline._punctuation = \"!\\\"#$%&'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~\";\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n// lookbehind is not available on Safari as of version 16\n// inline.escapedEmSt = /(?<=(?:^|[^\\\\)(?:\\\\[^])*)\\\\[*_]/g;\ninline.escapedEmSt = /(?:^|[^\\\\])(?:\\\\\\\\)*\\\\[*_]/g;\ninline._comment = edit(block._comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, \"g\").replace(/punct/g, inline._punctuation).getRegex();\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, \"g\").replace(/punct/g, inline._punctuation).getRegex();\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink).replace(\"scheme\", inline._scheme).replace(\"email\", inline._email).getRegex();\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\ninline.tag = edit(inline.tag).replace(\"comment\", inline._comment).replace(\"attribute\", inline._attribute).getRegex();\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\ninline.link = edit(inline.link).replace(\"label\", inline._label).replace(\"href\", inline._href).replace(\"title\", inline._title).getRegex();\ninline.reflink = edit(inline.reflink).replace(\"label\", inline._label).replace(\"ref\", block._label).getRegex();\ninline.nolink = edit(inline.nolink).replace(\"ref\", block._label).getRegex();\ninline.reflinkSearch = edit(inline.reflinkSearch, \"g\").replace(\"reflink\", inline.reflink).replace(\"nolink\", inline.nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ inline.normal = _extends({}, inline);\n/**\n * Pedantic Inline Grammar\n */ inline.pedantic = _extends({}, inline.normal, {\n    strong: {\n        start: /^__|\\*\\*/,\n        middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n        endAst: /\\*\\*(?!\\*)/g,\n        endUnd: /__(?!_)/g\n    },\n    em: {\n        start: /^_|\\*/,\n        middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n        endAst: /\\*(?!\\*)/g,\n        endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", inline._label).getRegex()\n});\n/**\n * GFM Inline Grammar\n */ inline.gfm = _extends({}, inline.normal, {\n    escape: edit(inline.escape).replace(\"])\", \"~|])\").getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n});\ninline.gfm.url = edit(inline.gfm.url, \"i\").replace(\"email\", inline.gfm._extended_email).getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */ inline.breaks = _extends({}, inline.gfm, {\n    br: edit(inline.br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inline.gfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n});\n/**\n * smartypants text replacement\n * @param {string} text\n */ function smartypants(text) {\n    return text// em-dashes\n    .replace(/---/g, \"—\")// en-dashes\n    .replace(/--/g, \"–\")// opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1‘\")// closing singles & apostrophes\n    .replace(/'/g, \"’\")// opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1“\")// closing doubles\n    .replace(/\"/g, \"”\")// ellipses\n    .replace(/\\.{3}/g, \"…\");\n}\n/**\n * mangle email addresses\n * @param {string} text\n */ function mangle(text) {\n    var out = \"\", i, ch;\n    var l = text.length;\n    for(i = 0; i < l; i++){\n        ch = text.charCodeAt(i);\n        if (Math.random() > 0.5) {\n            ch = \"x\" + ch.toString(16);\n        }\n        out += \"&#\" + ch + \";\";\n    }\n    return out;\n}\n/**\n * Block Lexer\n */ var Lexer = /*#__PURE__*/ function() {\n    function Lexer(options) {\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || exports.defaults;\n        this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        var rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n   * Expose Rules\n   */ /**\n   * Static Lex Method\n   */ Lexer.lex = function lex(src, options) {\n        var lexer = new Lexer(options);\n        return lexer.lex(src);\n    } /**\n   * Static Lex Inline Method\n   */ ;\n    Lexer.lexInline = function lexInline(src, options) {\n        var lexer = new Lexer(options);\n        return lexer.inlineTokens(src);\n    } /**\n   * Preprocessing\n   */ ;\n    var _proto = Lexer.prototype;\n    _proto.lex = function lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        var next;\n        while(next = this.inlineQueue.shift()){\n            this.inlineTokens(next.src, next.tokens);\n        }\n        return this.tokens;\n    } /**\n   * Lexing\n   */ ;\n    _proto.blockTokens = function blockTokens(src, tokens) {\n        var _this = this;\n        if (tokens === void 0) {\n            tokens = [];\n        }\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, function(_, leading, tabs) {\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        var token, lastToken, cutSrc, lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {\n                if (token = extTokenizer.call({\n                    lexer: _this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                (function() {\n                    var startIndex = Infinity;\n                    var tempSrc = src.slice(1);\n                    var tempStart = void 0;\n                    _this.options.extensions.startBlock.forEach(function(getStartIndex) {\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                })();\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                var errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    };\n    _proto.inline = function inline(src, tokens) {\n        if (tokens === void 0) {\n            tokens = [];\n        }\n        this.inlineQueue.push({\n            src: src,\n            tokens: tokens\n        });\n        return tokens;\n    } /**\n   * Lexing/Compiling\n   */ ;\n    _proto.inlineTokens = function inlineTokens(src, tokens) {\n        var _this2 = this;\n        if (tokens === void 0) {\n            tokens = [];\n        }\n        var token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        var maskedSrc = src;\n        var match;\n        var keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            var links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + repeatString(\"a\", match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + repeatString(\"a\", match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped em & strong delimiters\n        while((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n            this.tokenizer.rules.inline.escapedEmSt.lastIndex--;\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {\n                if (token = extTokenizer.call({\n                    lexer: _this2\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src, mangle)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                (function() {\n                    var startIndex = Infinity;\n                    var tempSrc = src.slice(1);\n                    var tempStart = void 0;\n                    _this2.options.extensions.startInline.forEach(function(getStartIndex) {\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                })();\n            }\n            if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                var errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    };\n    _createClass(Lexer, null, [\n        {\n            key: \"rules\",\n            get: function get() {\n                return {\n                    block: block,\n                    inline: inline\n                };\n            }\n        }\n    ]);\n    return Lexer;\n}();\n/**\n * Renderer\n */ var Renderer = /*#__PURE__*/ function() {\n    function Renderer(options) {\n        this.options = options || exports.defaults;\n    }\n    var _proto = Renderer.prototype;\n    _proto.code = function code(_code, infostring, escaped) {\n        var lang = (infostring || \"\").match(/\\S*/)[0];\n        if (this.options.highlight) {\n            var out = this.options.highlight(_code, lang);\n            if (out != null && out !== _code) {\n                escaped = true;\n                _code = out;\n            }\n        }\n        _code = _code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? _code : escape(_code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"' + this.options.langPrefix + escape(lang) + '\">' + (escaped ? _code : escape(_code, true)) + \"</code></pre>\\n\";\n    } /**\n   * @param {string} quote\n   */ ;\n    _proto.blockquote = function blockquote(quote) {\n        return \"<blockquote>\\n\" + quote + \"</blockquote>\\n\";\n    };\n    _proto.html = function html(_html) {\n        return _html;\n    } /**\n   * @param {string} text\n   * @param {string} level\n   * @param {string} raw\n   * @param {any} slugger\n   */ ;\n    _proto.heading = function heading(text, level, raw, slugger) {\n        if (this.options.headerIds) {\n            var id = this.options.headerPrefix + slugger.slug(raw);\n            return \"<h\" + level + ' id=\"' + id + '\">' + text + \"</h\" + level + \">\\n\";\n        }\n        // ignore IDs\n        return \"<h\" + level + \">\" + text + \"</h\" + level + \">\\n\";\n    };\n    _proto.hr = function hr() {\n        return this.options.xhtml ? \"<hr/>\\n\" : \"<hr>\\n\";\n    };\n    _proto.list = function list(body, ordered, start) {\n        var type = ordered ? \"ol\" : \"ul\", startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.listitem = function listitem(text) {\n        return \"<li>\" + text + \"</li>\\n\";\n    };\n    _proto.checkbox = function checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? \" /\" : \"\") + \"> \";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.paragraph = function paragraph(text) {\n        return \"<p>\" + text + \"</p>\\n\";\n    } /**\n   * @param {string} header\n   * @param {string} body\n   */ ;\n    _proto.table = function table(header, body) {\n        if (body) body = \"<tbody>\" + body + \"</tbody>\";\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    } /**\n   * @param {string} content\n   */ ;\n    _proto.tablerow = function tablerow(content) {\n        return \"<tr>\\n\" + content + \"</tr>\\n\";\n    };\n    _proto.tablecell = function tablecell(content, flags) {\n        var type = flags.header ? \"th\" : \"td\";\n        var tag = flags.align ? \"<\" + type + ' align=\"' + flags.align + '\">' : \"<\" + type + \">\";\n        return tag + content + (\"</\" + type + \">\\n\");\n    } /**\n   * span level renderer\n   * @param {string} text\n   */ ;\n    _proto.strong = function strong(text) {\n        return \"<strong>\" + text + \"</strong>\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.em = function em(text) {\n        return \"<em>\" + text + \"</em>\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.codespan = function codespan(text) {\n        return \"<code>\" + text + \"</code>\";\n    };\n    _proto.br = function br() {\n        return this.options.xhtml ? \"<br/>\" : \"<br>\";\n    } /**\n   * @param {string} text\n   */ ;\n    _proto.del = function del(text) {\n        return \"<del>\" + text + \"</del>\";\n    } /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */ ;\n    _proto.link = function link(href, title, text) {\n        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (href === null) {\n            return text;\n        }\n        var out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    } /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */ ;\n    _proto.image = function image(href, title, text) {\n        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n        if (href === null) {\n            return text;\n        }\n        var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += this.options.xhtml ? \"/>\" : \">\";\n        return out;\n    };\n    _proto.text = function text(_text) {\n        return _text;\n    };\n    return Renderer;\n}();\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ var TextRenderer = /*#__PURE__*/ function() {\n    function TextRenderer() {}\n    var _proto = TextRenderer.prototype;\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n        return text;\n    };\n    _proto.em = function em(text) {\n        return text;\n    };\n    _proto.codespan = function codespan(text) {\n        return text;\n    };\n    _proto.del = function del(text) {\n        return text;\n    };\n    _proto.html = function html(text) {\n        return text;\n    };\n    _proto.text = function text(_text) {\n        return _text;\n    };\n    _proto.link = function link(href, title, text) {\n        return \"\" + text;\n    };\n    _proto.image = function image(href, title, text) {\n        return \"\" + text;\n    };\n    _proto.br = function br() {\n        return \"\";\n    };\n    return TextRenderer;\n}();\n/**\n * Slugger generates header id\n */ var Slugger = /*#__PURE__*/ function() {\n    function Slugger() {\n        this.seen = {};\n    }\n    /**\n   * @param {string} value\n   */ var _proto = Slugger.prototype;\n    _proto.serialize = function serialize(value) {\n        return value.toLowerCase().trim()// remove html tags\n        .replace(/<[!\\/a-z].*?>/ig, \"\")// remove unwanted chars\n        .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, \"\").replace(/\\s/g, \"-\");\n    } /**\n   * Finds the next safe (unique) slug to use\n   * @param {string} originalSlug\n   * @param {boolean} isDryRun\n   */ ;\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n        var slug = originalSlug;\n        var occurenceAccumulator = 0;\n        if (this.seen.hasOwnProperty(slug)) {\n            occurenceAccumulator = this.seen[originalSlug];\n            do {\n                occurenceAccumulator++;\n                slug = originalSlug + \"-\" + occurenceAccumulator;\n            }while (this.seen.hasOwnProperty(slug));\n        }\n        if (!isDryRun) {\n            this.seen[originalSlug] = occurenceAccumulator;\n            this.seen[slug] = 0;\n        }\n        return slug;\n    } /**\n   * Convert string to unique id\n   * @param {object} [options]\n   * @param {boolean} [options.dryrun] Generates the next unique slug without\n   * updating the internal accumulator.\n   */ ;\n    _proto.slug = function slug(value, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var slug = this.serialize(value);\n        return this.getNextSafeSlug(slug, options.dryrun);\n    };\n    return Slugger;\n}();\n/**\n * Parsing & Compiling\n */ var Parser = /*#__PURE__*/ function() {\n    function Parser(options) {\n        this.options = options || exports.defaults;\n        this.options.renderer = this.options.renderer || new Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new TextRenderer();\n        this.slugger = new Slugger();\n    }\n    /**\n   * Static Parse Method\n   */ Parser.parse = function parse(tokens, options) {\n        var parser = new Parser(options);\n        return parser.parse(tokens);\n    } /**\n   * Static Parse Inline Method\n   */ ;\n    Parser.parseInline = function parseInline(tokens, options) {\n        var parser = new Parser(options);\n        return parser.parseInline(tokens);\n    } /**\n   * Parse Loop\n   */ ;\n    var _proto = Parser.prototype;\n    _proto.parse = function parse(tokens, top) {\n        if (top === void 0) {\n            top = true;\n        }\n        var out = \"\", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;\n        var l = tokens.length;\n        for(i = 0; i < l; i++){\n            token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        out += this.renderer.code(token.text, token.lang, token.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        header = \"\";\n                        // header\n                        cell = \"\";\n                        l2 = token.header.length;\n                        for(j = 0; j < l2; j++){\n                            cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                                header: true,\n                                align: token.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        body = \"\";\n                        l2 = token.rows.length;\n                        for(j = 0; j < l2; j++){\n                            row = token.rows[j];\n                            cell = \"\";\n                            l3 = row.length;\n                            for(k = 0; k < l3; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: token.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        body = this.parse(token.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        ordered = token.ordered;\n                        start = token.start;\n                        loose = token.loose;\n                        l2 = token.items.length;\n                        body = \"\";\n                        for(j = 0; j < l2; j++){\n                            item = token.items[j];\n                            checked = item.checked;\n                            task = item.task;\n                            itemBody = \"\";\n                            if (item.task) {\n                                checkbox = this.renderer.checkbox(checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox;\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        // TODO parse inline content if parameter markdown=1\n                        out += this.renderer.html(token.text);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        out += this.renderer.paragraph(this.parseInline(token.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        body = token.tokens ? this.parseInline(token.tokens) : token.text;\n                        while(i + 1 < l && tokens[i + 1].type === \"text\"){\n                            token = tokens[++i];\n                            body += \"\\n\" + (token.tokens ? this.parseInline(token.tokens) : token.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return;\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    } /**\n   * Parse Inline Tokens\n   */ ;\n    _proto.parseInline = function parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        var out = \"\", i, token, ret;\n        var l = tokens.length;\n        for(i = 0; i < l; i++){\n            token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        out += renderer.text(token.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        out += renderer.html(token.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        out += renderer.image(token.href, token.title, token.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        out += renderer.strong(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        out += renderer.em(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        out += renderer.codespan(token.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        out += renderer.del(this.parseInline(token.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        out += renderer.text(token.text);\n                        break;\n                    }\n                default:\n                    {\n                        var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return;\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    };\n    return Parser;\n}();\nvar Hooks = /*#__PURE__*/ function() {\n    function Hooks(options) {\n        this.options = options || exports.defaults;\n    }\n    var _proto = Hooks.prototype;\n    /**\n   * Process markdown before marked\n   */ _proto.preprocess = function preprocess(markdown) {\n        return markdown;\n    } /**\n   * Process HTML after marked is finished\n   */ ;\n    _proto.postprocess = function postprocess(html) {\n        return html;\n    };\n    return Hooks;\n}();\nHooks.passThroughHooks = new Set([\n    \"preprocess\",\n    \"postprocess\"\n]);\nfunction onError(silent, async, callback) {\n    return function(e) {\n        e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n        if (silent) {\n            var msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n            if (async) {\n                return Promise.resolve(msg);\n            }\n            if (callback) {\n                callback(null, msg);\n                return;\n            }\n            return msg;\n        }\n        if (async) {\n            return Promise.reject(e);\n        }\n        if (callback) {\n            callback(e);\n            return;\n        }\n        throw e;\n    };\n}\nfunction parseMarkdown(lexer, parser) {\n    return function(src, opt, callback) {\n        if (typeof opt === \"function\") {\n            callback = opt;\n            opt = null;\n        }\n        var origOpt = _extends({}, opt);\n        opt = _extends({}, marked.defaults, origOpt);\n        var throwError = onError(opt.silent, opt.async, callback);\n        // throw error in case of non string input\n        if (typeof src === \"undefined\" || src === null) {\n            return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n        }\n        if (typeof src !== \"string\") {\n            return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n        }\n        checkSanitizeDeprecation(opt);\n        if (opt.hooks) {\n            opt.hooks.options = opt;\n        }\n        if (callback) {\n            var highlight = opt.highlight;\n            var tokens;\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                tokens = lexer(src, opt);\n            } catch (e) {\n                return throwError(e);\n            }\n            var done = function done(err) {\n                var out;\n                if (!err) {\n                    try {\n                        if (opt.walkTokens) {\n                            marked.walkTokens(tokens, opt.walkTokens);\n                        }\n                        out = parser(tokens, opt);\n                        if (opt.hooks) {\n                            out = opt.hooks.postprocess(out);\n                        }\n                    } catch (e) {\n                        err = e;\n                    }\n                }\n                opt.highlight = highlight;\n                return err ? throwError(err) : callback(null, out);\n            };\n            if (!highlight || highlight.length < 3) {\n                return done();\n            }\n            delete opt.highlight;\n            if (!tokens.length) return done();\n            var pending = 0;\n            marked.walkTokens(tokens, function(token) {\n                if (token.type === \"code\") {\n                    pending++;\n                    setTimeout(function() {\n                        highlight(token.text, token.lang, function(err, code) {\n                            if (err) {\n                                return done(err);\n                            }\n                            if (code != null && code !== token.text) {\n                                token.text = code;\n                                token.escaped = true;\n                            }\n                            pending--;\n                            if (pending === 0) {\n                                done();\n                            }\n                        });\n                    }, 0);\n                }\n            });\n            if (pending === 0) {\n                done();\n            }\n            return;\n        }\n        if (opt.async) {\n            return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then(function(src) {\n                return lexer(src, opt);\n            }).then(function(tokens) {\n                return opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(function() {\n                    return tokens;\n                }) : tokens;\n            }).then(function(tokens) {\n                return parser(tokens, opt);\n            }).then(function(html) {\n                return opt.hooks ? opt.hooks.postprocess(html) : html;\n            })[\"catch\"](throwError);\n        }\n        try {\n            if (opt.hooks) {\n                src = opt.hooks.preprocess(src);\n            }\n            var _tokens = lexer(src, opt);\n            if (opt.walkTokens) {\n                marked.walkTokens(_tokens, opt.walkTokens);\n            }\n            var html = parser(_tokens, opt);\n            if (opt.hooks) {\n                html = opt.hooks.postprocess(html);\n            }\n            return html;\n        } catch (e) {\n            return throwError(e);\n        }\n    };\n}\n/**\n * Marked\n */ function marked(src, opt, callback) {\n    return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);\n}\n/**\n * Options\n */ marked.options = marked.setOptions = function(opt) {\n    marked.defaults = _extends({}, marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n};\nmarked.getDefaults = getDefaults;\nmarked.defaults = exports.defaults;\n/**\n * Use Extension\n */ marked.use = function() {\n    var extensions = marked.defaults.extensions || {\n        renderers: {},\n        childTokens: {}\n    };\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    args.forEach(function(pack) {\n        // copy options to new object\n        var opts = _extends({}, pack);\n        // set async to true if it was set to true before\n        opts.async = marked.defaults.async || opts.async || false;\n        // ==-- Parse \"addon\" extensions --== //\n        if (pack.extensions) {\n            pack.extensions.forEach(function(ext) {\n                if (!ext.name) {\n                    throw new Error(\"extension name required\");\n                }\n                if (ext.renderer) {\n                    // Renderer extensions\n                    var prevRenderer = extensions.renderers[ext.name];\n                    if (prevRenderer) {\n                        // Replace extension with func to run new extension but fall back if false\n                        extensions.renderers[ext.name] = function() {\n                            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                                args[_key2] = arguments[_key2];\n                            }\n                            var ret = ext.renderer.apply(this, args);\n                            if (ret === false) {\n                                ret = prevRenderer.apply(this, args);\n                            }\n                            return ret;\n                        };\n                    } else {\n                        extensions.renderers[ext.name] = ext.renderer;\n                    }\n                }\n                if (ext.tokenizer) {\n                    // Tokenizer Extensions\n                    if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                        throw new Error(\"extension level must be 'block' or 'inline'\");\n                    }\n                    if (extensions[ext.level]) {\n                        extensions[ext.level].unshift(ext.tokenizer);\n                    } else {\n                        extensions[ext.level] = [\n                            ext.tokenizer\n                        ];\n                    }\n                    if (ext.start) {\n                        // Function to check for start of token\n                        if (ext.level === \"block\") {\n                            if (extensions.startBlock) {\n                                extensions.startBlock.push(ext.start);\n                            } else {\n                                extensions.startBlock = [\n                                    ext.start\n                                ];\n                            }\n                        } else if (ext.level === \"inline\") {\n                            if (extensions.startInline) {\n                                extensions.startInline.push(ext.start);\n                            } else {\n                                extensions.startInline = [\n                                    ext.start\n                                ];\n                            }\n                        }\n                    }\n                }\n                if (ext.childTokens) {\n                    // Child tokens to be visited by walkTokens\n                    extensions.childTokens[ext.name] = ext.childTokens;\n                }\n            });\n            opts.extensions = extensions;\n        }\n        // ==-- Parse \"overwrite\" extensions --== //\n        if (pack.renderer) {\n            (function() {\n                var renderer = marked.defaults.renderer || new Renderer();\n                var _loop = function _loop(prop) {\n                    var prevRenderer = renderer[prop];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[prop] = function() {\n                        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n                            args[_key3] = arguments[_key3];\n                        }\n                        var ret = pack.renderer[prop].apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret;\n                    };\n                };\n                for(var prop in pack.renderer){\n                    _loop(prop);\n                }\n                opts.renderer = renderer;\n            })();\n        }\n        if (pack.tokenizer) {\n            (function() {\n                var tokenizer = marked.defaults.tokenizer || new Tokenizer();\n                var _loop2 = function _loop2(prop) {\n                    var prevTokenizer = tokenizer[prop];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    tokenizer[prop] = function() {\n                        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n                            args[_key4] = arguments[_key4];\n                        }\n                        var ret = pack.tokenizer[prop].apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                };\n                for(var prop in pack.tokenizer){\n                    _loop2(prop);\n                }\n                opts.tokenizer = tokenizer;\n            })();\n        }\n        // ==-- Parse Hooks extensions --== //\n        if (pack.hooks) {\n            (function() {\n                var hooks = marked.defaults.hooks || new Hooks();\n                var _loop3 = function _loop3(prop) {\n                    var prevHook = hooks[prop];\n                    if (Hooks.passThroughHooks.has(prop)) {\n                        hooks[prop] = function(arg) {\n                            if (marked.defaults.async) {\n                                return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then(function(ret) {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            var ret = pack.hooks[prop].call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        hooks[prop] = function() {\n                            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){\n                                args[_key5] = arguments[_key5];\n                            }\n                            var ret = pack.hooks[prop].apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                };\n                for(var prop in pack.hooks){\n                    _loop3(prop);\n                }\n                opts.hooks = hooks;\n            })();\n        }\n        // ==-- Parse WalkTokens extensions --== //\n        if (pack.walkTokens) {\n            var _walkTokens = marked.defaults.walkTokens;\n            opts.walkTokens = function(token) {\n                var values = [];\n                values.push(pack.walkTokens.call(this, token));\n                if (_walkTokens) {\n                    values = values.concat(_walkTokens.call(this, token));\n                }\n                return values;\n            };\n        }\n        marked.setOptions(opts);\n    });\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    var values = [];\n    var _loop4 = function _loop4() {\n        var token = _step.value;\n        values = values.concat(callback.call(marked, token));\n        switch(token.type){\n            case \"table\":\n                {\n                    for(var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;){\n                        var cell = _step2.value;\n                        values = values.concat(marked.walkTokens(cell.tokens, callback));\n                    }\n                    for(var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;){\n                        var row = _step3.value;\n                        for(var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;){\n                            var _cell = _step4.value;\n                            values = values.concat(marked.walkTokens(_cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n            case \"list\":\n                {\n                    values = values.concat(marked.walkTokens(token.items, callback));\n                    break;\n                }\n            default:\n                {\n                    if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {\n                        // Walk any extensions\n                        marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {\n                            values = values.concat(marked.walkTokens(token[childTokens], callback));\n                        });\n                    } else if (token.tokens) {\n                        values = values.concat(marked.walkTokens(token.tokens, callback));\n                    }\n                }\n        }\n    };\n    for(var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;){\n        _loop4();\n    }\n    return values;\n};\n/**\n * Parse Inline\n * @param {string} src\n */ marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);\n/**\n * Expose\n */ marked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.Tokenizer = Tokenizer;\nmarked.Slugger = Slugger;\nmarked.Hooks = Hooks;\nmarked.parse = marked;\nvar options = marked.options;\nvar setOptions = marked.setOptions;\nvar use = marked.use;\nvar walkTokens = marked.walkTokens;\nvar parseInline = marked.parseInline;\nvar parse = marked;\nvar parser = Parser.parse;\nvar lexer = Lexer.lex;\nexports.Hooks = Hooks;\nexports.Lexer = Lexer;\nexports.Parser = Parser;\nexports.Renderer = Renderer;\nexports.Slugger = Slugger;\nexports.TextRenderer = TextRenderer;\nexports.Tokenizer = Tokenizer;\nexports.getDefaults = getDefaults;\nexports.lexer = lexer;\nexports.marked = marked;\nexports.options = options;\nexports.parse = parse;\nexports.parseInline = parseInline;\nexports.parser = parser;\nexports.setOptions = setOptions;\nexports.use = use;\nexports.walkTokens = walkTokens;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuY2pzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FFRDs7O0NBR0MsR0FFRDtBQUVBLFNBQVNBLGtCQUFrQkMsTUFBTSxFQUFFQyxLQUFLO0lBQ3RDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7UUFDckMsSUFBSUUsYUFBYUgsS0FBSyxDQUFDQyxFQUFFO1FBQ3pCRSxXQUFXQyxVQUFVLEdBQUdELFdBQVdDLFVBQVUsSUFBSTtRQUNqREQsV0FBV0UsWUFBWSxHQUFHO1FBQzFCLElBQUksV0FBV0YsWUFBWUEsV0FBV0csUUFBUSxHQUFHO1FBQ2pEQyxPQUFPQyxjQUFjLENBQUNULFFBQVFVLGVBQWVOLFdBQVdPLEdBQUcsR0FBR1A7SUFDaEU7QUFDRjtBQUNBLFNBQVNRLGFBQWFDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ3hELElBQUlELFlBQVlmLGtCQUFrQmMsWUFBWUcsU0FBUyxFQUFFRjtJQUN6RCxJQUFJQyxhQUFhaEIsa0JBQWtCYyxhQUFhRTtJQUNoRFAsT0FBT0MsY0FBYyxDQUFDSSxhQUFhLGFBQWE7UUFDOUNOLFVBQVU7SUFDWjtJQUNBLE9BQU9NO0FBQ1Q7QUFDQSxTQUFTSTtJQUNQQSxXQUFXVCxPQUFPVSxNQUFNLEdBQUdWLE9BQU9VLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVuQixNQUFNO1FBQ2hFLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJa0IsVUFBVWpCLE1BQU0sRUFBRUQsSUFBSztZQUN6QyxJQUFJbUIsU0FBU0QsU0FBUyxDQUFDbEIsRUFBRTtZQUN6QixJQUFLLElBQUlTLE9BQU9VLE9BQVE7Z0JBQ3RCLElBQUliLE9BQU9RLFNBQVMsQ0FBQ00sY0FBYyxDQUFDQyxJQUFJLENBQUNGLFFBQVFWLE1BQU07b0JBQ3JEWCxNQUFNLENBQUNXLElBQUksR0FBR1UsTUFBTSxDQUFDVixJQUFJO2dCQUMz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QUFLO0FBQ3pCLElBQUkzTSxRQUFRa0osTUFBTUcsR0FBRztBQUVyQnpPLGFBQWEsR0FBR3lTO0FBQ2hCelMsYUFBYSxHQUFHc087QUFDaEJ0TyxjQUFjLEdBQUc2UjtBQUNqQjdSLGdCQUFnQixHQUFHbVE7QUFDbkJuUSxlQUFlLEdBQUdxUjtBQUNsQnJSLG9CQUFvQixHQUFHb1I7QUFDdkJwUixpQkFBaUIsR0FBR3FHO0FBQ3BCckcsbUJBQW1CLEdBQUdyQjtBQUN0QnFCLGFBQWEsR0FBR29GO0FBQ2hCcEYsY0FBYyxHQUFHd1Q7QUFDakJ4VCxlQUFlLEdBQUdzRztBQUNsQnRHLGFBQWEsR0FBRytSO0FBQ2hCL1IsbUJBQW1CLEdBQUdpUztBQUN0QmpTLGNBQWMsR0FBR2dTO0FBQ2pCaFMsa0JBQWtCLEdBQUdnVTtBQUNyQmhVLFdBQVcsR0FBR2lVO0FBQ2RqVSxrQkFBa0IsR0FBR0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdXNpY25leHRqcy8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5janM/Njk4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCB2NC4zLjAgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMjMsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkXG4gKi9cblxuLyoqXG4gKiBETyBOT1QgRURJVCBUSElTIEZJTEVcbiAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBmaWxlcyBpbiAuL3NyYy9cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRzKCkge1xuICByZXR1cm4ge1xuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBiYXNlVXJsOiBudWxsLFxuICAgIGJyZWFrczogZmFsc2UsXG4gICAgZXh0ZW5zaW9uczogbnVsbCxcbiAgICBnZm06IHRydWUsXG4gICAgaGVhZGVySWRzOiB0cnVlLFxuICAgIGhlYWRlclByZWZpeDogJycsXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgIGhvb2tzOiBudWxsLFxuICAgIGxhbmdQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgIG1hbmdsZTogdHJ1ZSxcbiAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgcmVuZGVyZXI6IG51bGwsXG4gICAgc2FuaXRpemU6IGZhbHNlLFxuICAgIHNhbml0aXplcjogbnVsbCxcbiAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICB0b2tlbml6ZXI6IG51bGwsXG4gICAgd2Fsa1Rva2VuczogbnVsbCxcbiAgICB4aHRtbDogZmFsc2VcbiAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgZXhwb3J0cy5kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xufVxuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xudmFyIGVzY2FwZVRlc3QgPSAvWyY8PlwiJ10vO1xudmFyIGVzY2FwZVJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3Quc291cmNlLCAnZycpO1xudmFyIGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspLztcbnZhciBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3ROb0VuY29kZS5zb3VyY2UsICdnJyk7XG52YXIgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xudmFyIGdldEVzY2FwZVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gZ2V0RXNjYXBlUmVwbGFjZW1lbnQoY2gpIHtcbiAgcmV0dXJuIGVzY2FwZVJlcGxhY2VtZW50c1tjaF07XG59O1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICBpZiAoZW5jb2RlKSB7XG4gICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59XG52YXIgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIC8vIGV4cGxpY2l0bHkgbWF0Y2ggZGVjaW1hbCwgaGV4LCBhbmQgbmFtZWQgSFRNTCBlbnRpdGllc1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgZnVuY3Rpb24gKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4JyA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSkgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG52YXIgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSByZWdleFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdFxuICovXG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSB0eXBlb2YgcmVnZXggPT09ICdzdHJpbmcnID8gcmVnZXggOiByZWdleC5zb3VyY2U7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgdmFyIG9iaiA9IHtcbiAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5hbWUsIHZhbCkge1xuICAgICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBnZXRSZWdleDogZnVuY3Rpb24gZ2V0UmVnZXgoKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBvYmo7XG59XG52YXIgbm9uV29yZEFuZENvbG9uVGVzdCA9IC9bXlxcdzpdL2c7XG52YXIgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2FuaXRpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICovXG5mdW5jdGlvbiBjbGVhblVybChzYW5pdGl6ZSwgYmFzZSwgaHJlZikge1xuICBpZiAoc2FuaXRpemUpIHtcbiAgICB2YXIgcHJvdDtcbiAgICB0cnkge1xuICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSkucmVwbGFjZShub25Xb3JkQW5kQ29sb25UZXN0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChiYXNlICYmICFvcmlnaW5JbmRlcGVuZGVudFVybC50ZXN0KGhyZWYpKSB7XG4gICAgaHJlZiA9IHJlc29sdmVVcmwoYmFzZSwgaHJlZik7XG4gIH1cbiAgdHJ5IHtcbiAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhyZWY7XG59XG52YXIgYmFzZVVybHMgPSB7fTtcbnZhciBqdXN0RG9tYWluID0gL15bXjpdKzpcXC8qW14vXSokLztcbnZhciBwcm90b2NvbCA9IC9eKFteOl0rOilbXFxzXFxTXSokLztcbnZhciBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBocmVmXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0oYmFzZSwgJy8nLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuICB2YXIgcmVsYXRpdmVCYXNlID0gYmFzZS5pbmRleE9mKCc6JykgPT09IC0xO1xuICBpZiAoaHJlZi5zdWJzdHJpbmcoMCwgMikgPT09ICcvLycpIHtcbiAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICByZXR1cm4gaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZShwcm90b2NvbCwgJyQxJykgKyBocmVmO1xuICB9IGVsc2UgaWYgKGhyZWYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICBpZiAocmVsYXRpdmVCYXNlKSB7XG4gICAgICByZXR1cm4gaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZShkb21haW4sICckMScpICsgaHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZSArIGhyZWY7XG4gIH1cbn1cbnZhciBub29wVGVzdCA9IHtcbiAgZXhlYzogZnVuY3Rpb24gbm9vcFRlc3QoKSB7fVxufTtcbmZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gIC8vIGJlZm9yZSBpdCB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIGFuIGVzY2FwZWQgcGlwZVxuICB2YXIgcm93ID0gdGFibGVSb3cucmVwbGFjZSgvXFx8L2csIGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHIpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgIGN1cnIgPSBvZmZzZXQ7XG4gICAgICB3aGlsZSAoLS1jdXJyID49IDAgJiYgc3RyW2N1cnJdID09PSAnXFxcXCcpIHtcbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgfVxuICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pO1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gRmlyc3QvbGFzdCBjZWxsIGluIGEgcm93IGNhbm5vdCBiZSBlbXB0eSBpZiBpdCBoYXMgbm8gbGVhZGluZy90cmFpbGluZyBwaXBlXG4gIGlmICghY2VsbHNbMF0udHJpbSgpKSB7XG4gICAgY2VsbHMuc2hpZnQoKTtcbiAgfVxuICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0udHJpbSgpKSB7XG4gICAgY2VsbHMucG9wKCk7XG4gIH1cbiAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgIGNlbGxzLnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGlzIGlnbm9yZWQgcGVyIHRoZSBnZm0gc3BlY1xuICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTtcbiAgfVxuICByZXR1cm4gY2VsbHM7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRyYWlsaW5nICdjJ3MuIEVxdWl2YWxlbnQgdG8gc3RyLnJlcGxhY2UoL2MqJC8sICcnKS5cbiAqIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW52ZXJ0IFJlbW92ZSBzdWZmaXggb2Ygbm9uLWMgY2hhcnMgaW5zdGVhZC4gRGVmYXVsdCBmYWxzZXkuXG4gKi9cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gIHZhciBsID0gc3RyLmxlbmd0aDtcbiAgaWYgKGwgPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICB2YXIgc3VmZkxlbiA9IDA7XG5cbiAgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG4gIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgIHZhciBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcbiAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgc3VmZkxlbisrO1xuICAgIH0gZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICBzdWZmTGVuKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyLnNsaWNlKDAsIGwgLSBzdWZmTGVuKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gIHZhciBsZXZlbCA9IDAsXG4gICAgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgIGxldmVsKys7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KSB7XG4gIGlmIChvcHQgJiYgb3B0LnNhbml0aXplICYmICFvcHQuc2lsZW50KSB7XG4gICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gIH1cbn1cblxuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU0NTAxMTMvODA2Nzc3XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqL1xuZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHBhdHRlcm4sIGNvdW50KSB7XG4gIGlmIChjb3VudCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgaWYgKGNvdW50ICYgMSkge1xuICAgICAgcmVzdWx0ICs9IHBhdHRlcm47XG4gICAgfVxuICAgIGNvdW50ID4+PSAxO1xuICAgIHBhdHRlcm4gKz0gcGF0dGVybjtcbiAgfVxuICByZXR1cm4gcmVzdWx0ICsgcGF0dGVybjtcbn1cblxuZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdywgbGV4ZXIpIHtcbiAgdmFyIGhyZWYgPSBsaW5rLmhyZWY7XG4gIHZhciB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuICB2YXIgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcbiAgaWYgKGNhcFswXS5jaGFyQXQoMCkgIT09ICchJykge1xuICAgIGxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgdmFyIHRva2VuID0ge1xuICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgcmF3OiByYXcsXG4gICAgICBocmVmOiBocmVmLFxuICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgfTtcbiAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnaW1hZ2UnLFxuICAgIHJhdzogcmF3LFxuICAgIGhyZWY6IGhyZWYsXG4gICAgdGl0bGU6IHRpdGxlLFxuICAgIHRleHQ6IGVzY2FwZSh0ZXh0KVxuICB9O1xufVxuZnVuY3Rpb24gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIHRleHQpIHtcbiAgdmFyIG1hdGNoSW5kZW50VG9Db2RlID0gcmF3Lm1hdGNoKC9eKFxccyspKD86YGBgKS8pO1xuICBpZiAobWF0Y2hJbmRlbnRUb0NvZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICB2YXIgaW5kZW50VG9Db2RlID0gbWF0Y2hJbmRlbnRUb0NvZGVbMV07XG4gIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgbWF0Y2hJbmRlbnRJbk5vZGUgPSBub2RlLm1hdGNoKC9eXFxzKy8pO1xuICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHZhciBpbmRlbnRJbk5vZGUgPSBtYXRjaEluZGVudEluTm9kZVswXTtcbiAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIFRva2VuaXplclxuICovXG52YXIgVG9rZW5pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGV4cG9ydHMuZGVmYXVsdHM7XG4gIH1cbiAgdmFyIF9wcm90byA9IFRva2VuaXplci5wcm90b3R5cGU7XG4gIF9wcm90by5zcGFjZSA9IGZ1bmN0aW9uIHNwYWNlKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5ld2xpbmUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmNvZGUgPSBmdW5jdGlvbiBjb2RlKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljID8gcnRyaW0odGV4dCwgJ1xcbicpIDogdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5mZW5jZXMgPSBmdW5jdGlvbiBmZW5jZXMoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgcmF3ID0gY2FwWzBdO1xuICAgICAgdmFyIHRleHQgPSBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgY2FwWzNdIHx8ICcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBjYXBbMl0sXG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaGVhZGluZy5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHRleHQgPSBjYXBbMl0udHJpbSgpO1xuXG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgI3NcbiAgICAgIGlmICgvIyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgdmFyIHRyaW1tZWQgPSBydHJpbSh0ZXh0LCAnIycpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5ociA9IGZ1bmN0aW9uIGhyKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICByYXc6IGNhcFswXVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5ibG9ja3F1b3RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eICo+WyBcXHRdPy9nbSwgJycpO1xuICAgICAgdmFyIHRvcCA9IHRoaXMubGV4ZXIuc3RhdGUudG9wO1xuICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0cnVlO1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnModGV4dCk7XG4gICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRvcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmxpc3QgPSBmdW5jdGlvbiBsaXN0KHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciByYXcsIGlzdGFzaywgaXNjaGVja2VkLCBpbmRlbnQsIGksIGJsYW5rTGluZSwgZW5kc1dpdGhCbGFua0xpbmUsIGxpbmUsIG5leHRMaW5lLCByYXdMaW5lLCBpdGVtQ29udGVudHMsIGVuZEVhcmx5O1xuICAgICAgdmFyIGJ1bGwgPSBjYXBbMV0udHJpbSgpO1xuICAgICAgdmFyIGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcbiAgICAgIHZhciBsaXN0ID0ge1xuICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgIHJhdzogJycsXG4gICAgICAgIG9yZGVyZWQ6IGlzb3JkZXJlZCxcbiAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgIGl0ZW1zOiBbXVxuICAgICAgfTtcbiAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBcIlxcXFxkezEsOX1cXFxcXCIgKyBidWxsLnNsaWNlKC0xKSA6IFwiXFxcXFwiICsgYnVsbDtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGJ1bGwgOiAnWyorLV0nO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgbmV4dCBsaXN0IGl0ZW1cbiAgICAgIHZhciBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKFwiXiggezAsM31cIiArIGJ1bGwgKyBcIikoKD86W1xcdCBdW15cXFxcbl0qKT8oPzpcXFxcbnwkKSlcIik7XG5cbiAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgYnVsbGV0IHBvaW50IGNhbiBzdGFydCBhIG5ldyBMaXN0IEl0ZW1cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgZW5kRWFybHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKCEoY2FwID0gaXRlbVJlZ2V4LmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHtcbiAgICAgICAgICAvLyBFbmQgbGlzdCBpZiBidWxsZXQgd2FzIGFjdHVhbGx5IEhSIChwb3NzaWJseSBtb3ZlIGludG8gaXRlbVJlZ2V4PylcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG4gICAgICAgIGxpbmUgPSBjYXBbMl0uc3BsaXQoJ1xcbicsIDEpWzBdLnJlcGxhY2UoL15cXHQrLywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gJyAnLnJlcGVhdCgzICogdC5sZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV4dExpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnRyaW1MZWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50ID0gY2FwWzJdLnNlYXJjaCgvW14gXS8pOyAvLyBGaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICBpbmRlbnQgKz0gY2FwWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFsaW5lICYmIC9eICokLy50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgIC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgIHJhdyArPSBuZXh0TGluZSArICdcXG4nO1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcobmV4dExpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5kRWFybHkpIHtcbiAgICAgICAgICB2YXIgbmV4dEJ1bGxldFJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4gezAsXCIgKyBNYXRoLm1pbigzLCBpbmRlbnQgLSAxKSArIFwifSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKVwiKTtcbiAgICAgICAgICB2YXIgaHJSZWdleCA9IG5ldyBSZWdFeHAoXCJeIHswLFwiICsgTWF0aC5taW4oMywgaW5kZW50IC0gMSkgKyBcIn0oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKVwiKTtcbiAgICAgICAgICB2YXIgZmVuY2VzQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoXCJeIHswLFwiICsgTWF0aC5taW4oMywgaW5kZW50IC0gMSkgKyBcIn0oPzpgYGB8fn5+KVwiKTtcbiAgICAgICAgICB2YXIgaGVhZGluZ0JlZ2luUmVnZXggPSBuZXcgUmVnRXhwKFwiXiB7MCxcIiArIE1hdGgubWluKDMsIGluZGVudCAtIDEpICsgXCJ9I1wiKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgcmF3TGluZSA9IHNyYy5zcGxpdCgnXFxuJywgMSlbMF07XG4gICAgICAgICAgICBuZXh0TGluZSA9IHJhd0xpbmU7XG5cbiAgICAgICAgICAgIC8vIFJlLWFsaWduIHRvIGZvbGxvdyBjb21tb25tYXJrIG5lc3RpbmcgcnVsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXh0TGluZS5yZXBsYWNlKC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csICcgICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIGNvZGUgZmVuY2VzXG4gICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgaGVhZGluZ1xuICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcbiAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0UmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhvcml6b250YWwgcnVsZSBmb3VuZFxuICAgICAgICAgICAgaWYgKGhyUmVnZXgudGVzdChzcmMpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRMaW5lLnNlYXJjaCgvW14gXS8pID49IGluZGVudCB8fCAhbmV4dExpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgIC8vIERlZGVudCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBwYXJhZ3JhcGggY29udGludWF0aW9uIHVubGVzcyBsYXN0IGxpbmUgd2FzIGEgZGlmZmVyZW50IGJsb2NrIGxldmVsIGVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGxpbmUuc2VhcmNoKC9bXiBdLykgPj0gNCkge1xuICAgICAgICAgICAgICAgIC8vIGluZGVudGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSAmJiAhbmV4dExpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgbGluZSBpcyBibGFua1xuICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpc3QubG9vc2UpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUpIHtcbiAgICAgICAgICAgIGxpc3QubG9vc2UgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL1xcbiAqXFxuICokLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgIGVuZHNXaXRoQmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgdGFzayBsaXN0IGl0ZW1zXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgaXN0YXNrID0gL15cXFtbIHhYXVxcXSAvLmV4ZWMoaXRlbUNvbnRlbnRzKTtcbiAgICAgICAgICBpZiAoaXN0YXNrKSB7XG4gICAgICAgICAgICBpc2NoZWNrZWQgPSBpc3Rhc2tbMF0gIT09ICdbIF0gJztcbiAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGl0ZW1Db250ZW50cy5yZXBsYWNlKC9eXFxbWyB4WF1cXF0gKy8sICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgbG9vc2U6IGZhbHNlLFxuICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50c1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5yYXcgKz0gcmF3O1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgY29uc3VtZSBuZXdsaW5lcyBhdCBlbmQgb2YgZmluYWwgaXRlbS4gQWx0ZXJuYXRpdmVseSwgbWFrZSBpdGVtUmVnZXggKnN0YXJ0KiB3aXRoIGFueSBuZXdsaW5lcyB0byBzaW1wbGlmeS9zcGVlZCB1cCBlbmRzV2l0aEJsYW5rTGluZSBsb2dpY1xuICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnJhdyA9IHJhdy50cmltUmlnaHQoKTtcbiAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS50ZXh0ID0gaXRlbUNvbnRlbnRzLnRyaW1SaWdodCgpO1xuICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltUmlnaHQoKTtcbiAgICAgIHZhciBsID0gbGlzdC5pdGVtcy5sZW5ndGg7XG5cbiAgICAgIC8vIEl0ZW0gY2hpbGQgdG9rZW5zIGhhbmRsZWQgaGVyZSBhdCBlbmQgYmVjYXVzZSB3ZSBuZWVkZWQgdG8gaGF2ZSB0aGUgZmluYWwgaXRlbSB0byB0cmltIGl0IGZpcnN0XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gZmFsc2U7XG4gICAgICAgIGxpc3QuaXRlbXNbaV0udG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2VucyhsaXN0Lml0ZW1zW2ldLnRleHQsIFtdKTtcbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgbGlzdCBzaG91bGQgYmUgbG9vc2VcbiAgICAgICAgICB2YXIgc3BhY2VycyA9IGxpc3QuaXRlbXNbaV0udG9rZW5zLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQudHlwZSA9PT0gJ3NwYWNlJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaGFzTXVsdGlwbGVMaW5lQnJlYWtzID0gc3BhY2Vycy5sZW5ndGggPiAwICYmIHNwYWNlcnMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIC9cXG4uKlxcbi8udGVzdCh0LnJhdyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGlzdC5sb29zZSA9IGhhc011bHRpcGxlTGluZUJyZWFrcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgYWxsIGl0ZW1zIHRvIGxvb3NlIGlmIGxpc3QgaXMgbG9vc2VcbiAgICAgIGlmIChsaXN0Lmxvb3NlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsaXN0Lml0ZW1zW2ldLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgdG9rZW4udHlwZSA9ICdwYXJhZ3JhcGgnO1xuICAgICAgICB0b2tlbi50ZXh0ID0gdGV4dDtcbiAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5sZXhlci5pbmxpbmUodGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZGVmID0gZnVuY3Rpb24gZGVmKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmRlZi5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgdmFyIHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIHZhciBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UoL148KC4qKT4kLywgJyQxJykucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiAnJztcbiAgICAgIHZhciB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogY2FwWzNdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RlZicsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnRhYmxlID0gZnVuY3Rpb24gdGFibGUoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IHNwbGl0Q2VsbHMoY2FwWzFdKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogY1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIHJvd3M6IGNhcFszXSAmJiBjYXBbM10udHJpbSgpID8gY2FwWzNdLnJlcGxhY2UoL1xcblsgXFx0XSokLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgaXRlbS5yYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgIHZhciBpLCBqLCBrLCByb3c7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGwgPSBpdGVtLnJvd3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaXRlbS5yb3dzW2ldID0gc3BsaXRDZWxscyhpdGVtLnJvd3NbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgY2hpbGQgdG9rZW5zIGluc2lkZSBoZWFkZXJzIGFuZCBjZWxsc1xuXG4gICAgICAgIC8vIGhlYWRlciBjaGlsZCB0b2tlbnNcbiAgICAgICAgbCA9IGl0ZW0uaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICAgIGl0ZW0uaGVhZGVyW2pdLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKGl0ZW0uaGVhZGVyW2pdLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2VsbCBjaGlsZCB0b2tlbnNcbiAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICByb3cgPSBpdGVtLnJvd3Nbal07XG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgcm93W2tdLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKHJvd1trXS50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubGhlYWRpbmcgPSBmdW5jdGlvbiBsaGVhZGluZyhzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saGVhZGluZy5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUoY2FwWzFdKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgdGV4dCA9IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJyA/IGNhcFsxXS5zbGljZSgwLCAtMSkgOiBjYXBbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dClcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uZXNjYXBlID0gZnVuY3Rpb24gZXNjYXBlJDEoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmVzY2FwZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBlc2NhcGUoY2FwWzFdKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by50YWcgPSBmdW5jdGlvbiB0YWcoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplID8gJ3RleHQnIDogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSkgOiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoc3JjKSB7XG4gICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmxpbmsuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciB0cmltbWVkVXJsID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnBlZGFudGljICYmIC9ePC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAvLyBjb21tb25tYXJrIHJlcXVpcmVzIG1hdGNoaW5nIGFuZ2xlIGJyYWNrZXRzXG4gICAgICAgIGlmICghLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kaW5nIGFuZ2xlIGJyYWNrZXQgY2Fubm90IGJlIGVzY2FwZWRcbiAgICAgICAgdmFyIHJ0cmltU2xhc2ggPSBydHJpbSh0cmltbWVkVXJsLnNsaWNlKDAsIC0xKSwgJ1xcXFwnKTtcbiAgICAgICAgaWYgKCh0cmltbWVkVXJsLmxlbmd0aCAtIHJ0cmltU2xhc2gubGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbmQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICB2YXIgbGFzdFBhcmVuSW5kZXggPSBmaW5kQ2xvc2luZ0JyYWNrZXQoY2FwWzJdLCAnKCknKTtcbiAgICAgICAgaWYgKGxhc3RQYXJlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBjYXBbMF0uaW5kZXhPZignIScpID09PSAwID8gNSA6IDQ7XG4gICAgICAgICAgdmFyIGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGhyZWYgPSBjYXBbMl07XG4gICAgICB2YXIgdGl0bGUgPSAnJztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgLy8gc3BsaXQgcGVkYW50aWMgaHJlZiBhbmQgdGl0bGVcbiAgICAgICAgdmFyIGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgfVxuICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEvPiQvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAvLyBwZWRhbnRpYyBhbGxvd3Mgc3RhcnRpbmcgYW5nbGUgYnJhY2tldCB3aXRob3V0IGVuZGluZyBhbmdsZSBicmFja2V0XG4gICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBocmVmLFxuICAgICAgICB0aXRsZTogdGl0bGUgPyB0aXRsZS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IHRpdGxlXG4gICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnJlZmxpbmsgPSBmdW5jdGlvbiByZWZsaW5rKHNyYywgbGlua3MpIHtcbiAgICB2YXIgY2FwO1xuICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpIHx8IChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgdmFyIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IGxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmVtU3Ryb25nID0gZnVuY3Rpb24gZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSB7XG4gICAgaWYgKHByZXZDaGFyID09PSB2b2lkIDApIHtcbiAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLmxEZWxpbS5leGVjKHNyYyk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuXG4gICAgLy8gXyBjYW4ndCBiZSBiZXR3ZWVuIHR3byBhbHBoYW51bWVyaWNzLiBcXHB7TH1cXHB7Tn0gaW5jbHVkZXMgbm9uLWVuZ2xpc2ggYWxwaGFiZXQvbnVtYmVycyBhcyB3ZWxsXG4gICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKC8oPzpbMC05QS1aYS16XFx4QUFcXHhCMlxceEIzXFx4QjVcXHhCOVxceEJBXFx4QkMtXFx4QkVcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVEMC1cXHUwNUVBXFx1MDVFRi1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2MC1cXHUwNjY5XFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0MwLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NkFcXHUwODcwLVxcdTA4ODdcXHUwODg5LVxcdTA4OEVcXHUwOEEwLVxcdTA4QzlcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUU2LVxcdTA5RjFcXHUwOUY0LVxcdTA5RjlcXHUwOUZDXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTZGXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjY2LVxcdTBCNkZcXHUwQjcxLVxcdTBCNzdcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQkU2LVxcdTBCRjJcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM1RFxcdTBDNjBcXHUwQzYxXFx1MEM2Ni1cXHUwQzZGXFx1MEM3OC1cXHUwQzdFXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0REXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDA0LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENTgtXFx1MEQ2MVxcdTBENjYtXFx1MEQ3OFxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwREU2LVxcdTBERUZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODYtXFx1MEU4QVxcdTBFOEMtXFx1MEVBM1xcdTBFQTVcXHUwRUE3LVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMjAtXFx1MEYzM1xcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0YtXFx1MTA0OVxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMDkwLVxcdTEwOTlcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM2OS1cXHUxMzdDXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzExXFx1MTcxRi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0Q1xcdTFCNTAtXFx1MUI1OVxcdTFCODMtXFx1MUJBMFxcdTFCQUUtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDOTAtXFx1MUNCQVxcdTFDQkQtXFx1MUNCRlxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUNGQVxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcwXFx1MjA3MVxcdTIwNzQtXFx1MjA3OVxcdTIwN0YtXFx1MjA4OVxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTUwLVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQzAwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJDRkRcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzE5Mi1cXHUzMTk1XFx1MzFBMC1cXHUzMUJGXFx1MzFGMC1cXHUzMUZGXFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1MzQwMC1cXHU0REJGXFx1NEUwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0NBXFx1QTdEMFxcdUE3RDFcXHVBN0QzXFx1QTdENS1cXHVBN0Q5XFx1QTdGMi1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTgzMC1cXHVBODM1XFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThEMC1cXHVBOEQ5XFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOEZFXFx1QTkwMC1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY5XFx1QUI3MC1cXHVBQkUyXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQwNy1cXHVERDMzXFx1REQ0MC1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUxLVxcdURFRkJcXHVERjAwLVxcdURGMjNcXHVERjJELVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REQ3MC1cXHVERDdBXFx1REQ3Qy1cXHVERDhBXFx1REQ4Qy1cXHVERDkyXFx1REQ5NFxcdUREOTVcXHVERDk3LVxcdUREQTFcXHVEREEzLVxcdUREQjFcXHVEREIzLVxcdUREQjlcXHVEREJCXFx1RERCQ1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N1xcdURGODAtXFx1REY4NVxcdURGODctXFx1REZCMFxcdURGQjItXFx1REZCQV18XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM1OC1cXHVEQzc2XFx1REM3OS1cXHVEQzlFXFx1RENBNy1cXHVEQ0FGXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVEQ0ZCLVxcdUREMUJcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJDLVxcdUREQ0ZcXHVEREQyLVxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzVcXHVERTQwLVxcdURFNDhcXHVERTYwLVxcdURFN0VcXHVERTgwLVxcdURFOUZcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERUVCLVxcdURFRUZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjU4LVxcdURGNzJcXHVERjc4LVxcdURGOTFcXHVERkE5LVxcdURGQUZdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXFx1RENGQS1cXHVERDIzXFx1REQzMC1cXHVERDM5XFx1REU2MC1cXHVERTdFXFx1REU4MC1cXHVERUE5XFx1REVCMFxcdURFQjFcXHVERjAwLVxcdURGMjdcXHVERjMwLVxcdURGNDVcXHVERjUxLVxcdURGNTRcXHVERjcwLVxcdURGODFcXHVERkIwLVxcdURGQ0JcXHVERkUwLVxcdURGRjZdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM1Mi1cXHVEQzZGXFx1REM3MVxcdURDNzJcXHVEQzc1XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMy1cXHVERDI2XFx1REQzNi1cXHVERDNGXFx1REQ0NFxcdURENDdcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREMC1cXHVERERBXFx1REREQ1xcdURERTEtXFx1RERGNFxcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERUYwLVxcdURFRjlcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM1MC1cXHVEQzU5XFx1REM1Ri1cXHVEQzYxXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVBQVxcdURFQjhcXHVERUMwLVxcdURFQzlcXHVERjAwLVxcdURGMUFcXHVERjMwLVxcdURGM0JcXHVERjQwLVxcdURGNDZdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzJCXFx1RENBMC1cXHVEQ0YyXFx1RENGRi1cXHVERDA2XFx1REQwOVxcdUREMEMtXFx1REQxM1xcdUREMTVcXHVERDE2XFx1REQxOC1cXHVERDJGXFx1REQzRlxcdURENDFcXHVERDUwLVxcdURENTlcXHVEREEwLVxcdUREQTdcXHVEREFBLVxcdURERDBcXHVEREUxXFx1RERFM1xcdURFMDBcXHVERTBCLVxcdURFMzJcXHVERTNBXFx1REU1MFxcdURFNUMtXFx1REU4OVxcdURFOURcXHVERUIwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNTAtXFx1REM2Q1xcdURDNzItXFx1REM4RlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDMwXFx1REQ0NlxcdURENTAtXFx1REQ1OVxcdURENjAtXFx1REQ2NVxcdURENjdcXHVERDY4XFx1REQ2QS1cXHVERDg5XFx1REQ5OFxcdUREQTAtXFx1RERBOVxcdURFRTAtXFx1REVGMlxcdURGQjBcXHVERkMwLVxcdURGRDRdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118XFx1RDgwQltcXHVERjkwLVxcdURGRjBdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDgyMlxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3MlxcdUQ4NzQtXFx1RDg3OVxcdUQ4ODAtXFx1RDg4M11bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REU3MC1cXHVERUJFXFx1REVDMC1cXHVERUM5XFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY1Qi1cXHVERjYxXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURFNDAtXFx1REU5NlxcdURGMDAtXFx1REY0QVxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXFx1REZFMVxcdURGRTNdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkY3XXxcXHVEODIzW1xcdURDMDAtXFx1RENENVxcdUREMDAtXFx1REQwOF18XFx1RDgyQltcXHVERkYwLVxcdURGRjNcXHVERkY1LVxcdURGRkJcXHVERkZEXFx1REZGRV18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMjJcXHVERDUwLVxcdURENTJcXHVERDY0LVxcdURENjdcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM0W1xcdURFRTAtXFx1REVGM1xcdURGNjAtXFx1REY3OF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODM3W1xcdURGMDAtXFx1REYxRV18XFx1RDgzOFtcXHVERDAwLVxcdUREMkNcXHVERDM3LVxcdUREM0RcXHVERDQwLVxcdURENDlcXHVERDRFXFx1REU5MC1cXHVERUFEXFx1REVDMC1cXHVERUVCXFx1REVGMC1cXHVERUY5XXxcXHVEODM5W1xcdURGRTAtXFx1REZFNlxcdURGRTgtXFx1REZFQlxcdURGRURcXHVERkVFXFx1REZGMC1cXHVERkZFXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDQzctXFx1RENDRlxcdUREMDAtXFx1REQ0M1xcdURENEJcXHVERDUwLVxcdURENTldfFxcdUQ4M0JbXFx1REM3MS1cXHVEQ0FCXFx1RENBRC1cXHVEQ0FGXFx1RENCMS1cXHVEQ0I0XFx1REQwMS1cXHVERDJEXFx1REQyRi1cXHVERDNEXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDgzQ1tcXHVERDAwLVxcdUREMENdfFxcdUQ4M0VbXFx1REZGMC1cXHVERkY5XXxcXHVEODY5W1xcdURDMDAtXFx1REVERlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzhcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMVxcdURFQjAtXFx1REZGRl18XFx1RDg3QVtcXHVEQzAwLVxcdURGRTBdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEODg0W1xcdURDMDAtXFx1REY0QV0pLykpIHJldHVybjtcbiAgICB2YXIgbmV4dENoYXIgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCAnJztcbiAgICBpZiAoIW5leHRDaGFyIHx8IG5leHRDaGFyICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSB7XG4gICAgICB2YXIgbExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgckRlbGltLFxuICAgICAgICByTGVuZ3RoLFxuICAgICAgICBkZWxpbVRvdGFsID0gbExlbmd0aCxcbiAgICAgICAgbWlkRGVsaW1Ub3RhbCA9IDA7XG4gICAgICB2YXIgZW5kUmVnID0gbWF0Y2hbMF1bMF0gPT09ICcqJyA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCA6IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nLnJEZWxpbVVuZDtcbiAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAvLyBDbGlwIG1hc2tlZFNyYyB0byBzYW1lIHNlY3Rpb24gb2Ygc3RyaW5nIGFzIHNyYyAobW92ZSB0byBsZXhlcj8pXG4gICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICByRGVsaW0gPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBtYXRjaFs2XTtcbiAgICAgICAgaWYgKCFyRGVsaW0pIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG5cbiAgICAgICAgckxlbmd0aCA9IHJEZWxpbS5sZW5ndGg7XG4gICAgICAgIGlmIChtYXRjaFszXSB8fCBtYXRjaFs0XSkge1xuICAgICAgICAgIC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkge1xuICAgICAgICAgIC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgaWYgKGxMZW5ndGggJSAzICYmICEoKGxMZW5ndGggKyByTGVuZ3RoKSAlIDMpKSB7XG4gICAgICAgICAgICBtaWREZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gQ29tbW9uTWFyayBFbXBoYXNpcyBSdWxlcyA5LTEwXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsaW1Ub3RhbCAtPSByTGVuZ3RoO1xuICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcblxuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuICAgICAgICB2YXIgcmF3ID0gc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIChtYXRjaFswXS5sZW5ndGggLSByRGVsaW0ubGVuZ3RoKSArIHJMZW5ndGgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBgZW1gIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgb2RkIGNoYXIgY291bnQuICphKioqXG4gICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICB2YXIgX3RleHQgPSByYXcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgICB0ZXh0OiBfdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoX3RleHQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSAnc3Ryb25nJyBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIGV2ZW4gY2hhciBjb3VudC4gKiphKioqXG4gICAgICAgIHZhciB0ZXh0ID0gcmF3LnNsaWNlKDIsIC0yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHNyYykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgdGV4dCA9IGNhcFsyXS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAgIHZhciBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICB2YXIgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSAvXiAvLnRlc3QodGV4dCkgJiYgLyAkLy50ZXN0KHRleHQpO1xuICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICB0ZXh0ID0gZXNjYXBlKHRleHQsIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicihzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbChzcmMpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQ6IGNhcFsyXSxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2VucyhjYXBbMl0pXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYXV0b2xpbmsuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHZhciB0ZXh0LCBocmVmO1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdG9rZW5zOiBbe1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9wcm90by51cmwgPSBmdW5jdGlvbiB1cmwoc3JjLCBtYW5nbGUpIHtcbiAgICB2YXIgY2FwO1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICB2YXIgdGV4dCwgaHJlZjtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgIHZhciBwcmV2Q2FwWmVybztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pWzBdO1xuICAgICAgICB9IHdoaWxlIChwcmV2Q2FwWmVybyAhPT0gY2FwWzBdKTtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICBpZiAoY2FwWzFdID09PSAnd3d3LicpIHtcbiAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgY2FwWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSBjYXBbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBzbWFydHlwYW50cykge1xuICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICB2YXIgdGV4dDtcbiAgICAgIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2spIHtcbiAgICAgICAgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBlc2NhcGUoY2FwWzBdKSA6IGNhcFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRva2VuaXplcjtcbn0oKTtcblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL14oPzogKig/OlxcbnwkKSkrLyxcbiAgY29kZTogL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy8sXG4gIGZlbmNlczogL14gezAsM30oYHszLH0oPz1bXmBcXG5dKig/OlxcbnwkKSl8fnszLH0pKFteXFxuXSopKD86XFxufCQpKD86fChbXFxzXFxTXSo/KSg/OlxcbnwkKSkoPzogezAsM31cXDFbfmBdKiAqKD89XFxufCQpfCQpLyxcbiAgaHI6IC9eIHswLDN9KCg/Oi1bXFx0IF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzpcXCpbIFxcdF0qKXszLH0pKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS8sXG4gIGJsb2NrcXVvdGU6IC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8sXG4gIGxpc3Q6IC9eKCB7MCwzfWJ1bGwpKFsgXFx0XVteXFxuXSs/KT8oPzpcXG58JCkvLFxuICBodG1sOiAnXiB7MCwzfSg/OicgLy8gb3B0aW9uYWwgaW5kZW50YXRpb25cbiAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICsgJ3w8XFxcXD9bXFxcXHNcXFxcU10qPyg/OlxcXFw/PlxcXFxuKnwkKScgLy8gKDMpXG4gICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICsgJ3w8Lz8odGFnKSg/OiArfFxcXFxufC8/PilbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNilcbiAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICArICd8PC8oPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVthLXpdW1xcXFx3LV0qXFxcXHMqPig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICArICcpJyxcbiAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICooPzpcXG4gKik/KFtePFxcc11bXlxcc10qfDwuKj8+KSg/Oig/OiArKD86XFxuICopP3wgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wVGVzdCxcbiAgbGhlYWRpbmc6IC9eKCg/Oi58XFxuKD8hXFxuKSkrPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgLy8gcmVnZXggdGVtcGxhdGUsIHBsYWNlaG9sZGVycyB3aWxsIGJlIHJlcGxhY2VkIGFjY29yZGluZyB0byBkaWZmZXJlbnQgcGFyYWdyYXBoXG4gIC8vIGludGVycnVwdGlvbiBydWxlcyBvZiBjb21tb25tYXJrIGFuZCB0aGUgb3JpZ2luYWwgbWFya2Rvd24gc3BlYzpcbiAgX3BhcmFncmFwaDogL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuYmxvY2suX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmJsb2NrLl90aXRsZSA9IC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS87XG5ibG9jay5kZWYgPSBlZGl0KGJsb2NrLmRlZikucmVwbGFjZSgnbGFiZWwnLCBibG9jay5fbGFiZWwpLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2suX3RpdGxlKS5nZXRSZWdleCgpO1xuYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuYmxvY2subGlzdEl0ZW1TdGFydCA9IGVkaXQoL14oICopKGJ1bGwpICovKS5yZXBsYWNlKCdidWxsJywgYmxvY2suYnVsbGV0KS5nZXRSZWdleCgpO1xuYmxvY2subGlzdCA9IGVkaXQoYmxvY2subGlzdCkucmVwbGFjZSgvYnVsbC9nLCBibG9jay5idWxsZXQpLnJlcGxhY2UoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/Oig/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcXFwqICopezMsfSkoPzpcXFxcbit8JCkpJykucmVwbGFjZSgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKS5nZXRSZWdleCgpO1xuYmxvY2suX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbicgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJyArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZScgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInICsgJ3x0cmFja3x1bCc7XG5ibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuYmxvY2suaHRtbCA9IGVkaXQoYmxvY2suaHRtbCwgJ2knKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pLmdldFJlZ2V4KCk7XG5ibG9jay5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4ucmVwbGFjZSgnfHRhYmxlJywgJycpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKS5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4ucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3Ncbi5nZXRSZWdleCgpO1xuYmxvY2suYmxvY2txdW90ZSA9IGVkaXQoYmxvY2suYmxvY2txdW90ZSkucmVwbGFjZSgncGFyYWdyYXBoJywgYmxvY2sucGFyYWdyYXBoKS5nZXRSZWdleCgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gX2V4dGVuZHMoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IF9leHRlbmRzKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgdGFibGU6ICdeICooW15cXFxcbiBdLipcXFxcfC4qKVxcXFxuJyAvLyBIZWFkZXJcbiAgKyAnIHswLDN9KD86XFxcXHwgKik/KDo/LSs6PyAqKD86XFxcXHwgKjo/LSs6PyAqKSopKD86XFxcXHwgKik/JyAvLyBBbGlnblxuICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcbn0pO1xuXG5ibG9jay5nZm0udGFibGUgPSBlZGl0KGJsb2NrLmdmbS50YWJsZSkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3Ncbi5nZXRSZWdleCgpO1xuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IGVkaXQoYmxvY2suX3BhcmFncmFwaCkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbi5yZXBsYWNlKCd0YWJsZScsIGJsb2NrLmdmbS50YWJsZSkgLy8gaW50ZXJydXB0IHBhcmFncmFwaHMgd2l0aCB0YWJsZVxuLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKS5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4ucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3Ncbi5nZXRSZWdleCgpO1xuLyoqXG4gKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gKi9cblxuYmxvY2sucGVkYW50aWMgPSBfZXh0ZW5kcyh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGh0bWw6IGVkaXQoJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJyArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudCkucmVwbGFjZSgvdGFnL2csICcoPyEoPzonICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJyArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKS5nZXRSZWdleCgpLFxuICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14oI3sxLDZ9KSguKikoPzpcXG4rfCQpLyxcbiAgZmVuY2VzOiBub29wVGVzdCxcbiAgLy8gZmVuY2VzIG5vdCBzdXBwb3J0ZWRcbiAgbGhlYWRpbmc6IC9eKC4rPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgcGFyYWdyYXBoOiBlZGl0KGJsb2NrLm5vcm1hbC5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrLmhyKS5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKS5yZXBsYWNlKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKS5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKS5yZXBsYWNlKCd8ZmVuY2VzJywgJycpLnJlcGxhY2UoJ3xsaXN0JywgJycpLnJlcGxhY2UoJ3xodG1sJywgJycpLmdldFJlZ2V4KClcbn0pO1xuXG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cbnZhciBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICB1cmw6IG5vb3BUZXN0LFxuICB0YWc6ICdeY29tbWVudCcgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgKyAnfF48W2EtekEtWl1bXFxcXHctXSooPzphdHRyaWJ1dGUpKj9cXFxccyovPz4nIC8vIG9wZW4gdGFnXG4gICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgKyAnfF48IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nLFxuICAvLyBDREFUQSBzZWN0aW9uXG4gIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhsYWJlbClcXF1cXFsocmVmKVxcXS8sXG4gIG5vbGluazogL14hP1xcWyhyZWYpXFxdKD86XFxbXFxdKT8vLFxuICByZWZsaW5rU2VhcmNoOiAncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLFxuICBlbVN0cm9uZzoge1xuICAgIGxEZWxpbTogL14oPzpcXCorKD86KFtwdW5jdF9dKXxbXlxccypdKSl8Xl8rKD86KFtwdW5jdCpdKXwoW15cXHNfXSkpLyxcbiAgICAvLyAgICAgICAgKDEpIGFuZCAoMikgY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXIuICgzKSBhbmQgKDQpIGNhbiBvbmx5IGJlIExlZnQuICAoNSkgYW5kICg2KSBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQuXG4gICAgLy8gICAgICAgICAgKCkgU2tpcCBvcnBoYW4gaW5zaWRlIHN0cm9uZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgQ29uc3VtZSB0byBkZWxpbSAgICAgKDEpICMqKiogICAgICAgICAgICAgICAgKDIpIGEqKiojLCBhKioqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICg0KSAqKiojICAgICAgICAgICAgICAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICg2KSBhKioqYVxuICAgIHJEZWxpbUFzdDogL14oPzpbXl8qXFxcXF18XFxcXC4pKj9cXF9cXF8oPzpbXl8qXFxcXF18XFxcXC4pKj9cXCooPzpbXl8qXFxcXF18XFxcXC4pKj8oPz1cXF9cXF8pfCg/OlteKlxcXFxdfFxcXFwuKSsoPz1bXipdKXxbcHVuY3RfXShcXCorKSg/PVtcXHNdfCQpfCg/OltecHVuY3QqX1xcc1xcXFxdfFxcXFwuKShcXCorKSg/PVtwdW5jdF9cXHNdfCQpfFtwdW5jdF9cXHNdKFxcKispKD89W15wdW5jdCpfXFxzXSl8W1xcc10oXFwqKykoPz1bcHVuY3RfXSl8W3B1bmN0X10oXFwqKykoPz1bcHVuY3RfXSl8KD86W15wdW5jdCpfXFxzXFxcXF18XFxcXC4pKFxcKispKD89W15wdW5jdCpfXFxzXSkvLFxuICAgIHJEZWxpbVVuZDogL14oPzpbXl8qXFxcXF18XFxcXC4pKj9cXCpcXCooPzpbXl8qXFxcXF18XFxcXC4pKj9cXF8oPzpbXl8qXFxcXF18XFxcXC4pKj8oPz1cXCpcXCopfCg/OlteX1xcXFxdfFxcXFwuKSsoPz1bXl9dKXxbcHVuY3QqXShcXF8rKSg/PVtcXHNdfCQpfCg/OltecHVuY3QqX1xcc1xcXFxdfFxcXFwuKShcXF8rKSg/PVtwdW5jdCpcXHNdfCQpfFtwdW5jdCpcXHNdKFxcXyspKD89W15wdW5jdCpfXFxzXSl8W1xcc10oXFxfKykoPz1bcHVuY3QqXSl8W3B1bmN0Kl0oXFxfKykoPz1bcHVuY3QqXSkvIC8vIF4tIE5vdCBhbGxvd2VkIGZvciBfXG4gIH0sXG5cbiAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgYnI6IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wVGVzdCxcbiAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLyxcbiAgcHVuY3R1YXRpb246IC9eKFtcXHNwdW5jdHVhdGlvbl0pL1xufTtcblxuLy8gbGlzdCBvZiBwdW5jdHVhdGlvbiBtYXJrcyBmcm9tIENvbW1vbk1hcmsgc3BlY1xuLy8gd2l0aG91dCAqIGFuZCBfIHRvIGhhbmRsZSB0aGUgZGlmZmVyZW50IGVtcGhhc2lzIG1hcmtlcnMgKiBhbmQgX1xuaW5saW5lLl9wdW5jdHVhdGlvbiA9ICchXCIjJCUmXFwnKCkrXFxcXC0uLC86Ozw9Pj9AXFxcXFtcXFxcXWBee3x9fic7XG5pbmxpbmUucHVuY3R1YXRpb24gPSBlZGl0KGlubGluZS5wdW5jdHVhdGlvbikucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcblxuLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cbmlubGluZS5ibG9ja1NraXAgPSAvXFxbW15cXF1dKj9cXF1cXChbXlxcKV0qP1xcKXxgW15gXSo/YHw8W14+XSo/Pi9nO1xuLy8gbG9va2JlaGluZCBpcyBub3QgYXZhaWxhYmxlIG9uIFNhZmFyaSBhcyBvZiB2ZXJzaW9uIDE2XG4vLyBpbmxpbmUuZXNjYXBlZEVtU3QgPSAvKD88PSg/Ol58W15cXFxcKSg/OlxcXFxbXl0pKilcXFxcWypfXS9nO1xuaW5saW5lLmVzY2FwZWRFbVN0ID0gLyg/Ol58W15cXFxcXSkoPzpcXFxcXFxcXCkqXFxcXFsqX10vZztcbmlubGluZS5fY29tbWVudCA9IGVkaXQoYmxvY2suX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuaW5saW5lLmVtU3Ryb25nLmxEZWxpbSA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLmxEZWxpbSkucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgPSBlZGl0KGlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QsICdnJykucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQgPSBlZGl0KGlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQsICdnJykucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbmlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS9nO1xuaW5saW5lLl9zY2hlbWUgPSAvW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfS87XG5pbmxpbmUuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG5pbmxpbmUuYXV0b2xpbmsgPSBlZGl0KGlubGluZS5hdXRvbGluaykucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lLl9zY2hlbWUpLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLl9lbWFpbCkuZ2V0UmVnZXgoKTtcbmlubGluZS5fYXR0cmlidXRlID0gL1xccytbYS16QS1aOl9dW1xcdy46LV0qKD86XFxzKj1cXHMqXCJbXlwiXSpcInxcXHMqPVxccyonW14nXSonfFxccyo9XFxzKlteXFxzXCInPTw+YF0rKT8vO1xuaW5saW5lLnRhZyA9IGVkaXQoaW5saW5lLnRhZykucmVwbGFjZSgnY29tbWVudCcsIGlubGluZS5fY29tbWVudCkucmVwbGFjZSgnYXR0cmlidXRlJywgaW5saW5lLl9hdHRyaWJ1dGUpLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2xhYmVsID0gLyg/OlxcWyg/OlxcXFwufFteXFxbXFxdXFxcXF0pKlxcXXxcXFxcLnxgW15gXSpgfFteXFxbXFxdXFxcXGBdKSo/LztcbmlubGluZS5faHJlZiA9IC88KD86XFxcXC58W15cXG48PlxcXFxdKSs+fFteXFxzXFx4MDAtXFx4MWZdKi87XG5pbmxpbmUuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG5pbmxpbmUubGluayA9IGVkaXQoaW5saW5lLmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZikucmVwbGFjZSgndGl0bGUnLCBpbmxpbmUuX3RpdGxlKS5nZXRSZWdleCgpO1xuaW5saW5lLnJlZmxpbmsgPSBlZGl0KGlubGluZS5yZWZsaW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLnJlcGxhY2UoJ3JlZicsIGJsb2NrLl9sYWJlbCkuZ2V0UmVnZXgoKTtcbmlubGluZS5ub2xpbmsgPSBlZGl0KGlubGluZS5ub2xpbmspLnJlcGxhY2UoJ3JlZicsIGJsb2NrLl9sYWJlbCkuZ2V0UmVnZXgoKTtcbmlubGluZS5yZWZsaW5rU2VhcmNoID0gZWRpdChpbmxpbmUucmVmbGlua1NlYXJjaCwgJ2cnKS5yZXBsYWNlKCdyZWZsaW5rJywgaW5saW5lLnJlZmxpbmspLnJlcGxhY2UoJ25vbGluaycsIGlubGluZS5ub2xpbmspLmdldFJlZ2V4KCk7XG5cbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLm5vcm1hbCA9IF9leHRlbmRzKHt9LCBpbmxpbmUpO1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0gX2V4dGVuZHMoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgc3Ryb25nOiB7XG4gICAgc3RhcnQ6IC9eX198XFwqXFwqLyxcbiAgICBtaWRkbGU6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICAgIGVuZEFzdDogL1xcKlxcKig/IVxcKikvZyxcbiAgICBlbmRVbmQ6IC9fXyg/IV8pL2dcbiAgfSxcbiAgZW06IHtcbiAgICBzdGFydDogL15ffFxcKi8sXG4gICAgbWlkZGxlOiAvXigpXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKil8Xl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pLyxcbiAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgZW5kVW5kOiAvXyg/IV8pL2dcbiAgfSxcbiAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKS5nZXRSZWdleCgpLFxuICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkuZ2V0UmVnZXgoKVxufSk7XG5cbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmdmbSA9IF9leHRlbmRzKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIGVzY2FwZTogZWRpdChpbmxpbmUuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgX2V4dGVuZGVkX2VtYWlsOiAvW0EtWmEtejAtOS5fKy1dKyhAKVthLXpBLVowLTktX10rKD86XFwuW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XSkrKD8hWy1fXSkvLFxuICB1cmw6IC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLyxcbiAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gIGRlbDogL14ofn4/KSg/PVteXFxzfl0pKFtcXHNcXFNdKj9bXlxcc35dKVxcMSg/PVtefl18JCkvLFxuICB0ZXh0OiAvXihbYH5dK3xbXmB+XSkoPzooPz0gezIsfVxcbil8KD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl9dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkpL1xufSk7XG5pbmxpbmUuZ2ZtLnVybCA9IGVkaXQoaW5saW5lLmdmbS51cmwsICdpJykucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuZ2ZtLl9leHRlbmRlZF9lbWFpbCkuZ2V0UmVnZXgoKTtcbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuYnJlYWtzID0gX2V4dGVuZHMoe30sIGlubGluZS5nZm0sIHtcbiAgYnI6IGVkaXQoaW5saW5lLmJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICB0ZXh0OiBlZGl0KGlubGluZS5nZm0udGV4dCkucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJykucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKS5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBzbWFydHlwYW50cyB0ZXh0IHJlcGxhY2VtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICovXG5mdW5jdGlvbiBzbWFydHlwYW50cyh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gIC8vIGVtLWRhc2hlc1xuICAucmVwbGFjZSgvLS0tL2csIFwiXFx1MjAxNFwiKVxuICAvLyBlbi1kYXNoZXNcbiAgLnJlcGxhY2UoLy0tL2csIFwiXFx1MjAxM1wiKVxuICAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csIFwiJDFcXHUyMDE4XCIpXG4gIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gIC5yZXBsYWNlKC8nL2csIFwiXFx1MjAxOVwiKVxuICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csIFwiJDFcXHUyMDFDXCIpXG4gIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAucmVwbGFjZSgvXCIvZywgXCJcXHUyMDFEXCIpXG4gIC8vIGVsbGlwc2VzXG4gIC5yZXBsYWNlKC9cXC57M30vZywgXCJcXHUyMDI2XCIpO1xufVxuXG4vKipcbiAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKi9cbmZ1bmN0aW9uIG1hbmdsZSh0ZXh0KSB7XG4gIHZhciBvdXQgPSAnJyxcbiAgICBpLFxuICAgIGNoO1xuICB2YXIgbCA9IHRleHQubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xudmFyIExleGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZXhwb3J0cy5kZWZhdWx0cztcbiAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyKCk7XG4gICAgdGhpcy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyO1xuICAgIHRoaXMudG9rZW5pemVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaW5MaW5rOiBmYWxzZSxcbiAgICAgIGluUmF3QmxvY2s6IGZhbHNlLFxuICAgICAgdG9wOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgcnVsZXMgPSB7XG4gICAgICBibG9jazogYmxvY2subm9ybWFsLFxuICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICBydWxlcy5ibG9jayA9IGJsb2NrLnBlZGFudGljO1xuICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLnBlZGFudGljO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuYnJlYWtzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmdmbTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgUnVsZXNcbiAgICovXG4gIC8qKlxuICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgKi9cbiAgTGV4ZXIubGV4ID0gZnVuY3Rpb24gbGV4KHNyYywgb3B0aW9ucykge1xuICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAqLztcbiAgTGV4ZXIubGV4SW5saW5lID0gZnVuY3Rpb24gbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHJvY2Vzc2luZ1xuICAgKi87XG4gIHZhciBfcHJvdG8gPSBMZXhlci5wcm90b3R5cGU7XG4gIF9wcm90by5sZXggPSBmdW5jdGlvbiBsZXgoc3JjKSB7XG4gICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpO1xuICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgdmFyIG5leHQ7XG4gICAgd2hpbGUgKG5leHQgPSB0aGlzLmlubGluZVF1ZXVlLnNoaWZ0KCkpIHtcbiAgICAgIHRoaXMuaW5saW5lVG9rZW5zKG5leHQuc3JjLCBuZXh0LnRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXhpbmdcbiAgICovO1xuICBfcHJvdG8uYmxvY2tUb2tlbnMgPSBmdW5jdGlvbiBibG9ja1Rva2VucyhzcmMsIHRva2Vucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRva2VucyA9PT0gdm9pZCAwKSB7XG4gICAgICB0b2tlbnMgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL14oICopKFxcdCspL2dtLCBmdW5jdGlvbiAoXywgbGVhZGluZywgdGFicykge1xuICAgICAgICByZXR1cm4gbGVhZGluZyArICcgICAgJy5yZXBlYXQodGFicy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciB0b2tlbiwgbGFzdFRva2VuLCBjdXRTcmMsIGxhc3RQYXJhZ3JhcGhDbGlwcGVkO1xuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9jayAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9jay5zb21lKGZ1bmN0aW9uIChleHRUb2tlbml6ZXIpIHtcbiAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoe1xuICAgICAgICAgIGxleGVyOiBfdGhpc1xuICAgICAgICB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbmV3bGluZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBpZiAodG9rZW4ucmF3Lmxlbmd0aCA9PT0gMSAmJiB0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBzaW5nbGUgXFxuIGFzIGEgc3BhY2VyLCBpdCdzIHRlcm1pbmF0aW5nIHRoZSBsYXN0IGxpbmUsXG4gICAgICAgICAgLy8gc28gbW92ZSBpdCB0aGVyZSBzbyB0aGF0IHdlIGRvbid0IGdldCB1bmVjZXNzYXJ5IHBhcmFncmFwaCB0YWdzXG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5yYXcgKz0gJ1xcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb2RlXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gQW4gaW5kZW50ZWQgY29kZSBibG9jayBjYW5ub3QgaW50ZXJydXB0IGEgcGFyYWdyYXBoLlxuICAgICAgICBpZiAobGFzdFRva2VuICYmIChsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0JykpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBmZW5jZXNcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGhlYWRpbmdcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhlYWRpbmcoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBoclxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHIoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBibG9ja3F1b3RlXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbGlzdFxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGh0bWxcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmh0bWwoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWZcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddKSB7XG4gICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRva2VuLmhyZWYsXG4gICAgICAgICAgICB0aXRsZTogdG9rZW4udGl0bGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFibGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBsaGVhZGluZ1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgICAvLyBwcmV2ZW50IHBhcmFncmFwaCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICB2YXIgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICB2YXIgdGVtcFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgIF90aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goZnVuY3Rpb24gKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7XG4gICAgICAgICAgICAgIGxleGVyOiB0aGlzXG4gICAgICAgICAgICB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUudG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChjdXRTcmMpKSkge1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFBhcmFncmFwaENsaXBwZWQgJiYgbGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aDtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRleHRcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuICBfcHJvdG8uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lKHNyYywgdG9rZW5zKSB7XG4gICAgaWYgKHRva2VucyA9PT0gdm9pZCAwKSB7XG4gICAgICB0b2tlbnMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5pbmxpbmVRdWV1ZS5wdXNoKHtcbiAgICAgIHNyYzogc3JjLFxuICAgICAgdG9rZW5zOiB0b2tlbnNcbiAgICB9KTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIExleGluZy9Db21waWxpbmdcbiAgICovO1xuICBfcHJvdG8uaW5saW5lVG9rZW5zID0gZnVuY3Rpb24gaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgaWYgKHRva2VucyA9PT0gdm9pZCAwKSB7XG4gICAgICB0b2tlbnMgPSBbXTtcbiAgICB9XG4gICAgdmFyIHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYztcblxuICAgIC8vIFN0cmluZyB3aXRoIGxpbmtzIG1hc2tlZCB0byBhdm9pZCBpbnRlcmZlcmVuY2Ugd2l0aCBlbSBhbmQgc3Ryb25nXG4gICAgdmFyIG1hc2tlZFNyYyA9IHNyYztcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIGtlZXBQcmV2Q2hhciwgcHJldkNoYXI7XG5cbiAgICAvLyBNYXNrIG91dCByZWZsaW5rc1xuICAgIGlmICh0aGlzLnRva2Vucy5saW5rcykge1xuICAgICAgdmFyIGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChsaW5rcy5pbmNsdWRlcyhtYXRjaFswXS5zbGljZShtYXRjaFswXS5sYXN0SW5kZXhPZignWycpICsgMSwgLTEpKSkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArIHJlcGVhdFN0cmluZygnYScsIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArIHJlcGVhdFN0cmluZygnYScsIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBNYXNrIG91dCBlc2NhcGVkIGVtICYgc3Ryb25nIGRlbGltaXRlcnNcbiAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmVzY2FwZWRFbVN0LmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnKysnICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5lc2NhcGVkRW1TdC5sYXN0SW5kZXgpO1xuICAgICAgdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmVzY2FwZWRFbVN0Lmxhc3RJbmRleC0tO1xuICAgIH1cbiAgICB3aGlsZSAoc3JjKSB7XG4gICAgICBpZiAoIWtlZXBQcmV2Q2hhcikge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG5cbiAgICAgIC8vIGV4dGVuc2lvbnNcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuaW5saW5lLnNvbWUoZnVuY3Rpb24gKGV4dFRva2VuaXplcikge1xuICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7XG4gICAgICAgICAgbGV4ZXI6IF90aGlzMlxuICAgICAgICB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNjYXBlXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lc2NhcGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0YWdcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvZGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGVzcGFuKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYnJcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVsIChnZm0pXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhdXRvbGlua1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYXV0b2xpbmsoc3JjLCBtYW5nbGUpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXh0XG4gICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgIHZhciB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICAgIHZhciB0ZW1wU3RhcnQgPSB2b2lkIDA7XG4gICAgICAgICAgX3RoaXMyLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKGZ1bmN0aW9uIChnZXRTdGFydEluZGV4KSB7XG4gICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoe1xuICAgICAgICAgICAgICBsZXhlcjogdGhpc1xuICAgICAgICAgICAgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoY3V0U3JjLCBzbWFydHlwYW50cykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRva2VuLnJhdy5zbGljZSgtMSkgIT09ICdfJykge1xuICAgICAgICAgIC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICB9XG4gICAgICAgIGtlZXBQcmV2Q2hhciA9IHRydWU7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNyYykge1xuICAgICAgICB2YXIgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuICBfY3JlYXRlQ2xhc3MoTGV4ZXIsIG51bGwsIFt7XG4gICAga2V5OiBcInJ1bGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgIGlubGluZTogaW5saW5lXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGV4ZXI7XG59KCk7XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xudmFyIFJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZXhwb3J0cy5kZWZhdWx0cztcbiAgfVxuICB2YXIgX3Byb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoX2NvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgICB2YXIgbGFuZyA9IChpbmZvc3RyaW5nIHx8ICcnKS5tYXRjaCgvXFxTKi8pWzBdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChfY29kZSwgbGFuZyk7XG4gICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBfY29kZSkge1xuICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgX2NvZGUgPSBvdXQ7XG4gICAgICB9XG4gICAgfVxuICAgIF9jb2RlID0gX2NvZGUucmVwbGFjZSgvXFxuJC8sICcnKSArICdcXG4nO1xuICAgIGlmICghbGFuZykge1xuICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPicgKyAoZXNjYXBlZCA/IF9jb2RlIDogZXNjYXBlKF9jb2RlLCB0cnVlKSkgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgfVxuICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIicgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeCArIGVzY2FwZShsYW5nKSArICdcIj4nICsgKGVzY2FwZWQgPyBfY29kZSA6IGVzY2FwZShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdW90ZVxuICAgKi87XG4gIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShxdW90ZSkge1xuICAgIHJldHVybiBcIjxibG9ja3F1b3RlPlxcblwiICsgcXVvdGUgKyBcIjwvYmxvY2txdW90ZT5cXG5cIjtcbiAgfTtcbiAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKF9odG1sKSB7XG4gICAgcmV0dXJuIF9odG1sO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3XG4gICAqIEBwYXJhbSB7YW55fSBzbHVnZ2VyXG4gICAqLztcbiAgX3Byb3RvLmhlYWRpbmcgPSBmdW5jdGlvbiBoZWFkaW5nKHRleHQsIGxldmVsLCByYXcsIHNsdWdnZXIpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgICAgdmFyIGlkID0gdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeCArIHNsdWdnZXIuc2x1ZyhyYXcpO1xuICAgICAgcmV0dXJuIFwiPGhcIiArIGxldmVsICsgXCIgaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCI+XCIgKyB0ZXh0ICsgXCI8L2hcIiArIGxldmVsICsgXCI+XFxuXCI7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIElEc1xuICAgIHJldHVybiBcIjxoXCIgKyBsZXZlbCArIFwiPlwiICsgdGV4dCArIFwiPC9oXCIgKyBsZXZlbCArIFwiPlxcblwiO1xuICB9O1xuICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgfTtcbiAgX3Byb3RvLmxpc3QgPSBmdW5jdGlvbiBsaXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KSB7XG4gICAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCcsXG4gICAgICBzdGFydGF0dCA9IG9yZGVyZWQgJiYgc3RhcnQgIT09IDEgPyAnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJyA6ICcnO1xuICAgIHJldHVybiAnPCcgKyB0eXBlICsgc3RhcnRhdHQgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovO1xuICBfcHJvdG8ubGlzdGl0ZW0gPSBmdW5jdGlvbiBsaXN0aXRlbSh0ZXh0KSB7XG4gICAgcmV0dXJuIFwiPGxpPlwiICsgdGV4dCArIFwiPC9saT5cXG5cIjtcbiAgfTtcbiAgX3Byb3RvLmNoZWNrYm94ID0gZnVuY3Rpb24gY2hlY2tib3goY2hlY2tlZCkge1xuICAgIHJldHVybiAnPGlucHV0ICcgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKSArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiJyArICh0aGlzLm9wdGlvbnMueGh0bWwgPyAnIC8nIDogJycpICsgJz4gJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi87XG4gIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgodGV4dCkge1xuICAgIHJldHVybiBcIjxwPlwiICsgdGV4dCArIFwiPC9wPlxcblwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHlcbiAgICovO1xuICBfcHJvdG8udGFibGUgPSBmdW5jdGlvbiB0YWJsZShoZWFkZXIsIGJvZHkpIHtcbiAgICBpZiAoYm9keSkgYm9keSA9IFwiPHRib2R5PlwiICsgYm9keSArIFwiPC90Ym9keT5cIjtcbiAgICByZXR1cm4gJzx0YWJsZT5cXG4nICsgJzx0aGVhZD5cXG4nICsgaGVhZGVyICsgJzwvdGhlYWQ+XFxuJyArIGJvZHkgKyAnPC90YWJsZT5cXG4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqLztcbiAgX3Byb3RvLnRhYmxlcm93ID0gZnVuY3Rpb24gdGFibGVyb3coY29udGVudCkge1xuICAgIHJldHVybiBcIjx0cj5cXG5cIiArIGNvbnRlbnQgKyBcIjwvdHI+XFxuXCI7XG4gIH07XG4gIF9wcm90by50YWJsZWNlbGwgPSBmdW5jdGlvbiB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgIHZhciB0YWcgPSBmbGFncy5hbGlnbiA/IFwiPFwiICsgdHlwZSArIFwiIGFsaWduPVxcXCJcIiArIGZsYWdzLmFsaWduICsgXCJcXFwiPlwiIDogXCI8XCIgKyB0eXBlICsgXCI+XCI7XG4gICAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAoXCI8L1wiICsgdHlwZSArIFwiPlxcblwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqLztcbiAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgcmV0dXJuIFwiPHN0cm9uZz5cIiArIHRleHQgKyBcIjwvc3Ryb25nPlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqLztcbiAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgIHJldHVybiBcIjxlbT5cIiArIHRleHQgKyBcIjwvZW0+XCI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovO1xuICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgcmV0dXJuIFwiPGNvZGU+XCIgKyB0ZXh0ICsgXCI8L2NvZGU+XCI7XG4gIH07XG4gIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqLztcbiAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbCh0ZXh0KSB7XG4gICAgcmV0dXJuIFwiPGRlbD5cIiArIHRleHQgKyBcIjwvZGVsPlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi87XG4gIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICB9XG4gICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovO1xuICBfcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZhciBvdXQgPSBcIjxpbWcgc3JjPVxcXCJcIiArIGhyZWYgKyBcIlxcXCIgYWx0PVxcXCJcIiArIHRleHQgKyBcIlxcXCJcIjtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIG91dCArPSBcIiB0aXRsZT1cXFwiXCIgKyB0aXRsZSArIFwiXFxcIlwiO1xuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICByZXR1cm4gX3RleHQ7XG4gIH07XG4gIHJldHVybiBSZW5kZXJlcjtcbn0oKTtcblxuLyoqXG4gKiBUZXh0UmVuZGVyZXJcbiAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICovXG52YXIgVGV4dFJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGV4dFJlbmRlcmVyKCkge31cbiAgdmFyIF9wcm90byA9IFRleHRSZW5kZXJlci5wcm90b3R5cGU7XG4gIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG4gIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICByZXR1cm4gX3RleHQ7XG4gIH07XG4gIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH07XG4gIF9wcm90by5pbWFnZSA9IGZ1bmN0aW9uIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfTtcbiAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuICByZXR1cm4gVGV4dFJlbmRlcmVyO1xufSgpO1xuXG4vKipcbiAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICovXG52YXIgU2x1Z2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNsdWdnZXIoKSB7XG4gICAgdGhpcy5zZWVuID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB2YXIgX3Byb3RvID0gU2x1Z2dlci5wcm90b3R5cGU7XG4gIF9wcm90by5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKClcbiAgICAvLyByZW1vdmUgaHRtbCB0YWdzXG4gICAgLnJlcGxhY2UoLzxbIVxcL2Etel0uKj8+L2lnLCAnJylcbiAgICAvLyByZW1vdmUgdW53YW50ZWQgY2hhcnNcbiAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpLnJlcGxhY2UoL1xccy9nLCAnLScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBuZXh0IHNhZmUgKHVuaXF1ZSkgc2x1ZyB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbmFsU2x1Z1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRHJ5UnVuXG4gICAqLztcbiAgX3Byb3RvLmdldE5leHRTYWZlU2x1ZyA9IGZ1bmN0aW9uIGdldE5leHRTYWZlU2x1ZyhvcmlnaW5hbFNsdWcsIGlzRHJ5UnVuKSB7XG4gICAgdmFyIHNsdWcgPSBvcmlnaW5hbFNsdWc7XG4gICAgdmFyIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gMDtcbiAgICBpZiAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKSB7XG4gICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IHRoaXMuc2VlbltvcmlnaW5hbFNsdWddO1xuICAgICAgZG8ge1xuICAgICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvcisrO1xuICAgICAgICBzbHVnID0gb3JpZ2luYWxTbHVnICsgJy0nICsgb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICB9IHdoaWxlICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpO1xuICAgIH1cbiAgICBpZiAoIWlzRHJ5UnVuKSB7XG4gICAgICB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXSA9IG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgdGhpcy5zZWVuW3NsdWddID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHNsdWc7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBzdHJpbmcgdG8gdW5pcXVlIGlkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kcnlydW5dIEdlbmVyYXRlcyB0aGUgbmV4dCB1bmlxdWUgc2x1ZyB3aXRob3V0XG4gICAqIHVwZGF0aW5nIHRoZSBpbnRlcm5hbCBhY2N1bXVsYXRvci5cbiAgICovO1xuICBfcHJvdG8uc2x1ZyA9IGZ1bmN0aW9uIHNsdWcodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHZhciBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldE5leHRTYWZlU2x1ZyhzbHVnLCBvcHRpb25zLmRyeXJ1bik7XG4gIH07XG4gIHJldHVybiBTbHVnZ2VyO1xufSgpO1xuXG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xudmFyIFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBleHBvcnRzLmRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnRleHRSZW5kZXJlciA9IG5ldyBUZXh0UmVuZGVyZXIoKTtcbiAgICB0aGlzLnNsdWdnZXIgPSBuZXcgU2x1Z2dlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAgICovXG4gIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2Vucywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgKi87XG4gIFBhcnNlci5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBMb29wXG4gICAqLztcbiAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2VucywgdG9wKSB7XG4gICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgICB0b3AgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gJycsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIGssXG4gICAgICBsMixcbiAgICAgIGwzLFxuICAgICAgcm93LFxuICAgICAgY2VsbCxcbiAgICAgIGhlYWRlcixcbiAgICAgIGJvZHksXG4gICAgICB0b2tlbixcbiAgICAgIG9yZGVyZWQsXG4gICAgICBzdGFydCxcbiAgICAgIGxvb3NlLFxuICAgICAgaXRlbUJvZHksXG4gICAgICBpdGVtLFxuICAgICAgY2hlY2tlZCxcbiAgICAgIHRhc2ssXG4gICAgICBjaGVja2JveCxcbiAgICAgIHJldDtcbiAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdLmNhbGwoe1xuICAgICAgICAgIHBhcnNlcjogdGhpc1xuICAgICAgICB9LCB0b2tlbik7XG4gICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ3NwYWNlJywgJ2hyJywgJ2hlYWRpbmcnLCAnY29kZScsICd0YWJsZScsICdibG9ja3F1b3RlJywgJ2xpc3QnLCAnaHRtbCcsICdwYXJhZ3JhcGgnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSwgdG9rZW4uZGVwdGgsIHVuZXNjYXBlKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCB0aGlzLnRleHRSZW5kZXJlcikpLCB0aGlzLnNsdWdnZXIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsIHRva2VuLmxhbmcsIHRva2VuLmVzY2FwZWQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaGVhZGVyID0gJyc7XG5cbiAgICAgICAgICAgIC8vIGhlYWRlclxuICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLmhlYWRlcltqXS50b2tlbnMpLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFsaWduOiB0b2tlbi5hbGlnbltqXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgICAgbDIgPSB0b2tlbi5yb3dzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgIHJvdyA9IHRva2VuLnJvd3Nbal07XG4gICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgbDMgPSByb3cubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbDM7IGsrKykge1xuICAgICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwodGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSwge1xuICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGFsaWduOiB0b2tlbi5hbGlnbltrXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvcmRlcmVkID0gdG9rZW4ub3JkZXJlZDtcbiAgICAgICAgICAgIHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgICBsb29zZSA9IHRva2VuLmxvb3NlO1xuICAgICAgICAgICAgbDIgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBib2R5ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICBpdGVtID0gdG9rZW4uaXRlbXNbal07XG4gICAgICAgICAgICAgIGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG4gICAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG4gICAgICAgICAgICAgIGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgICAgICBjaGVja2JveCA9IHRoaXMucmVuZGVyZXIuY2hlY2tib3goY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGl0ZW1Cb2R5LCB0YXNrLCBjaGVja2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPIHBhcnNlIGlubGluZSBjb250ZW50IGlmIHBhcmFtZXRlciBtYXJrZG93bj0xXG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcbiAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IGwgJiYgdG9rZW5zW2kgKyAxXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSB0b3AgPyB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaChib2R5KSA6IGJvZHk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAqLztcbiAgX3Byb3RvLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICB2YXIgb3V0ID0gJycsXG4gICAgICBpLFxuICAgICAgdG9rZW4sXG4gICAgICByZXQ7XG4gICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgIHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHtcbiAgICAgICAgICBwYXJzZXI6IHRoaXNcbiAgICAgICAgfSwgdG9rZW4pO1xuICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydlc2NhcGUnLCAnaHRtbCcsICdsaW5rJywgJ2ltYWdlJywgJ3N0cm9uZycsICdlbScsICdjb2Rlc3BhbicsICdicicsICdkZWwnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2VzY2FwZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5odG1sKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIubGluayh0b2tlbi5ocmVmLCB0b2tlbi50aXRsZSwgdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRva2VuLnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5zdHJvbmcodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZW0odGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvZGVzcGFuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4odG9rZW4udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuYnIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZGVsKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuICByZXR1cm4gUGFyc2VyO1xufSgpO1xuXG52YXIgSG9va3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIb29rcyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBleHBvcnRzLmRlZmF1bHRzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBIb29rcy5wcm90b3R5cGU7XG4gIC8qKlxuICAgKiBQcm9jZXNzIG1hcmtkb3duIGJlZm9yZSBtYXJrZWRcbiAgICovXG4gIF9wcm90by5wcmVwcm9jZXNzID0gZnVuY3Rpb24gcHJlcHJvY2VzcyhtYXJrZG93bikge1xuICAgIHJldHVybiBtYXJrZG93bjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIEhUTUwgYWZ0ZXIgbWFya2VkIGlzIGZpbmlzaGVkXG4gICAqLztcbiAgX3Byb3RvLnBvc3Rwcm9jZXNzID0gZnVuY3Rpb24gcG9zdHByb2Nlc3MoaHRtbCkge1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICByZXR1cm4gSG9va3M7XG59KCk7XG5Ib29rcy5wYXNzVGhyb3VnaEhvb2tzID0gbmV3IFNldChbJ3ByZXByb2Nlc3MnLCAncG9zdHByb2Nlc3MnXSk7XG5cbmZ1bmN0aW9uIG9uRXJyb3Ioc2lsZW50LCBhc3luYywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgIGlmIChzaWxlbnQpIHtcbiAgICAgIHZhciBtc2cgPSAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICAgIGlmIChhc3luYykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU1hcmtkb3duKGxleGVyLCBwYXJzZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgb3JpZ09wdCA9IF9leHRlbmRzKHt9LCBvcHQpO1xuICAgIG9wdCA9IF9leHRlbmRzKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9yaWdPcHQpO1xuICAgIHZhciB0aHJvd0Vycm9yID0gb25FcnJvcihvcHQuc2lsZW50LCBvcHQuYXN5bmMsIGNhbGxiYWNrKTtcblxuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgfVxuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpO1xuICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgIG9wdC5ob29rcy5vcHRpb25zID0gb3B0O1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgdmFyIHRva2VucztcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VucyA9IGxleGVyKHNyYywgb3B0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgIHZhciBvdXQ7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCA9IHBhcnNlcih0b2tlbnMsIG9wdCk7XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgIG91dCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBlcnIgPyB0aHJvd0Vycm9yKGVycikgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgICAgfTtcbiAgICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcbiAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuIGRvbmUoKTtcbiAgICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VucywgZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24gKGVyciwgY29kZSkge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsICYmIGNvZGUgIT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHQuYXN5bmMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKSA6IHNyYykudGhlbihmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgIHJldHVybiBsZXhlcihzcmMsIG9wdCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwobWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2VucykpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgIH0pIDogdG9rZW5zO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICByZXR1cm4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKGh0bWwpIDogaHRtbDtcbiAgICAgIH0pW1wiY2F0Y2hcIl0odGhyb3dFcnJvcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgIHNyYyA9IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYyk7XG4gICAgICB9XG4gICAgICB2YXIgX3Rva2VucyA9IGxleGVyKHNyYywgb3B0KTtcbiAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICBtYXJrZWQud2Fsa1Rva2VucyhfdG9rZW5zLCBvcHQud2Fsa1Rva2Vucyk7XG4gICAgICB9XG4gICAgICB2YXIgaHRtbCA9IHBhcnNlcihfdG9rZW5zLCBvcHQpO1xuICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICBodG1sID0gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKGh0bWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IoZSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBwYXJzZU1hcmtkb3duKExleGVyLmxleCwgUGFyc2VyLnBhcnNlKShzcmMsIG9wdCwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdCkge1xuICBtYXJrZWQuZGVmYXVsdHMgPSBfZXh0ZW5kcyh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICByZXR1cm4gbWFya2VkO1xufTtcbm1hcmtlZC5nZXREZWZhdWx0cyA9IGdldERlZmF1bHRzO1xubWFya2VkLmRlZmF1bHRzID0gZXhwb3J0cy5kZWZhdWx0cztcblxuLyoqXG4gKiBVc2UgRXh0ZW5zaW9uXG4gKi9cblxubWFya2VkLnVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4dGVuc2lvbnMgPSBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucyB8fCB7XG4gICAgcmVuZGVyZXJzOiB7fSxcbiAgICBjaGlsZFRva2Vuczoge31cbiAgfTtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHBhY2spIHtcbiAgICAvLyBjb3B5IG9wdGlvbnMgdG8gbmV3IG9iamVjdFxuICAgIHZhciBvcHRzID0gX2V4dGVuZHMoe30sIHBhY2spO1xuXG4gICAgLy8gc2V0IGFzeW5jIHRvIHRydWUgaWYgaXQgd2FzIHNldCB0byB0cnVlIGJlZm9yZVxuICAgIG9wdHMuYXN5bmMgPSBtYXJrZWQuZGVmYXVsdHMuYXN5bmMgfHwgb3B0cy5hc3luYyB8fCBmYWxzZTtcblxuICAgIC8vID09LS0gUGFyc2UgXCJhZGRvblwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgICAgaWYgKCFleHQubmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5zaW9uIG5hbWUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0LnJlbmRlcmVyKSB7XG4gICAgICAgICAgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgIHZhciBwcmV2UmVuZGVyZXIgPSBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV07XG4gICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBleHRlbnNpb24gd2l0aCBmdW5jIHRvIHJ1biBuZXcgZXh0ZW5zaW9uIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciByZXQgPSBleHQucmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHQudG9rZW5pemVyKSB7XG4gICAgICAgICAgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICBpZiAoIWV4dC5sZXZlbCB8fCBleHQubGV2ZWwgIT09ICdibG9jaycgJiYgZXh0LmxldmVsICE9PSAnaW5saW5lJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5zaW9uIGxldmVsIG11c3QgYmUgJ2Jsb2NrJyBvciAnaW5saW5lJ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbnNbZXh0LmxldmVsXSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0LmxldmVsXSA9IFtleHQudG9rZW5pemVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dC5zdGFydCkge1xuICAgICAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHN0YXJ0IG9mIHRva2VuXG4gICAgICAgICAgICBpZiAoZXh0LmxldmVsID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jayA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dC5sZXZlbCA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dC5jaGlsZFRva2Vucykge1xuICAgICAgICAgIC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICBleHRlbnNpb25zLmNoaWxkVG9rZW5zW2V4dC5uYW1lXSA9IGV4dC5jaGlsZFRva2VucztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvcHRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICBpZiAocGFjay5yZW5kZXJlcikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gbWFya2VkLmRlZmF1bHRzLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcigpO1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3Byb3BdO1xuICAgICAgICAgIC8vIFJlcGxhY2UgcmVuZGVyZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICByZW5kZXJlcltwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmV0ID0gcGFjay5yZW5kZXJlcltwcm9wXS5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICBfbG9vcChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgICBpZiAocGFjay50b2tlbml6ZXIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbml6ZXIgPSBtYXJrZWQuZGVmYXVsdHMudG9rZW5pemVyIHx8IG5ldyBUb2tlbml6ZXIoKTtcbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbcHJvcF07XG4gICAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICB0b2tlbml6ZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJldCA9IHBhY2sudG9rZW5pemVyW3Byb3BdLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIC8vID09LS0gUGFyc2UgSG9va3MgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgaWYgKHBhY2suaG9va3MpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBob29rcyA9IG1hcmtlZC5kZWZhdWx0cy5ob29rcyB8fCBuZXcgSG9va3MoKTtcbiAgICAgICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZIb29rID0gaG9va3NbcHJvcF07XG4gICAgICAgICAgaWYgKEhvb2tzLnBhc3NUaHJvdWdoSG9va3MuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICBob29rc1twcm9wXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgaWYgKG1hcmtlZC5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFjay5ob29rc1twcm9wXS5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKGZ1bmN0aW9uIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciByZXQgPSBwYWNrLmhvb2tzW3Byb3BdLmNhbGwoaG9va3MsIGFyZyk7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3NbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcmV0ID0gcGFjay5ob29rc1twcm9wXS5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgX2xvb3AzKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuaG9va3MgPSBob29rcztcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLndhbGtUb2tlbnMpIHtcbiAgICAgIHZhciBfd2Fsa1Rva2VucyA9IG1hcmtlZC5kZWZhdWx0cy53YWxrVG9rZW5zO1xuICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFsdWVzLnB1c2gocGFjay53YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgaWYgKF93YWxrVG9rZW5zKSB7XG4gICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChfd2Fsa1Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH07XG4gICAgfVxuICAgIG1hcmtlZC5zZXRPcHRpb25zKG9wdHMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5cbm1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY2FsbGJhY2spIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgX2xvb3A0ID0gZnVuY3Rpb24gX2xvb3A0KCkge1xuICAgIHZhciB0b2tlbiA9IF9zdGVwLnZhbHVlO1xuICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoY2FsbGJhY2suY2FsbChtYXJrZWQsIHRva2VuKSk7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0b2tlbi5oZWFkZXIpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0b2tlbi5yb3dzKSwgX3N0ZXAzOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyb3cpLCBfc3RlcDQ7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNCgpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX2NlbGwgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQobWFya2VkLndhbGtUb2tlbnMoX2NlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAvLyBXYWxrIGFueSBleHRlbnNpb25zXG4gICAgICAgICAgICBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1t0b2tlbi50eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFRva2Vucykge1xuICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKHRva2VuW2NoaWxkVG9rZW5zXSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICBfbG9vcDQoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBQYXJzZSBJbmxpbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAqL1xubWFya2VkLnBhcnNlSW5saW5lID0gcGFyc2VNYXJrZG93bihMZXhlci5sZXhJbmxpbmUsIFBhcnNlci5wYXJzZUlubGluZSk7XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5tYXJrZWQuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5tYXJrZWQuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xubWFya2VkLkhvb2tzID0gSG9va3M7XG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG52YXIgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xudmFyIHNldE9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucztcbnZhciB1c2UgPSBtYXJrZWQudXNlO1xudmFyIHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbnZhciBwYXJzZUlubGluZSA9IG1hcmtlZC5wYXJzZUlubGluZTtcbnZhciBwYXJzZSA9IG1hcmtlZDtcbnZhciBwYXJzZXIgPSBQYXJzZXIucGFyc2U7XG52YXIgbGV4ZXIgPSBMZXhlci5sZXg7XG5cbmV4cG9ydHMuSG9va3MgPSBIb29rcztcbmV4cG9ydHMuTGV4ZXIgPSBMZXhlcjtcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuZXhwb3J0cy5TbHVnZ2VyID0gU2x1Z2dlcjtcbmV4cG9ydHMuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyO1xuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5leHBvcnRzLmdldERlZmF1bHRzID0gZ2V0RGVmYXVsdHM7XG5leHBvcnRzLmxleGVyID0gbGV4ZXI7XG5leHBvcnRzLm1hcmtlZCA9IG1hcmtlZDtcbmV4cG9ydHMub3B0aW9ucyA9IG9wdGlvbnM7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnBhcnNlSW5saW5lID0gcGFyc2VJbmxpbmU7XG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbmV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG5leHBvcnRzLnVzZSA9IHVzZTtcbmV4cG9ydHMud2Fsa1Rva2VucyA9IHdhbGtUb2tlbnM7XG4iXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwiYXJndW1lbnRzIiwic291cmNlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJvIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm5leHQiLCJpc0FycmF5IiwiZG9uZSIsInZhbHVlIiwiVHlwZUVycm9yIiwiX3RvUHJpbWl0aXZlIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiU3RyaW5nIiwiTnVtYmVyIiwiYXJnIiwiZ2V0RGVmYXVsdHMiLCJhc3luYyIsImJhc2VVcmwiLCJicmVha3MiLCJleHRlbnNpb25zIiwiZ2ZtIiwiaGVhZGVySWRzIiwiaGVhZGVyUHJlZml4IiwiaGlnaGxpZ2h0IiwiaG9va3MiLCJsYW5nUHJlZml4IiwibWFuZ2xlIiwicGVkYW50aWMiLCJyZW5kZXJlciIsInNhbml0aXplIiwic2FuaXRpemVyIiwic2lsZW50Iiwic21hcnR5cGFudHMiLCJ0b2tlbml6ZXIiLCJ3YWxrVG9rZW5zIiwieGh0bWwiLCJleHBvcnRzIiwiZGVmYXVsdHMiLCJjaGFuZ2VEZWZhdWx0cyIsIm5ld0RlZmF1bHRzIiwiZXNjYXBlVGVzdCIsImVzY2FwZVJlcGxhY2UiLCJSZWdFeHAiLCJlc2NhcGVUZXN0Tm9FbmNvZGUiLCJlc2NhcGVSZXBsYWNlTm9FbmNvZGUiLCJlc2NhcGVSZXBsYWNlbWVudHMiLCJnZXRFc2NhcGVSZXBsYWNlbWVudCIsImNoIiwiZXNjYXBlIiwiaHRtbCIsImVuY29kZSIsInJlcGxhY2UiLCJ1bmVzY2FwZVRlc3QiLCJ1bmVzY2FwZSIsIl8iLCJ0b0xvd2VyQ2FzZSIsImNoYXJBdCIsImZyb21DaGFyQ29kZSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiY2FyZXQiLCJlZGl0IiwicmVnZXgiLCJvcHQiLCJvYmoiLCJ2YWwiLCJnZXRSZWdleCIsIm5vbldvcmRBbmRDb2xvblRlc3QiLCJvcmlnaW5JbmRlcGVuZGVudFVybCIsImNsZWFuVXJsIiwiYmFzZSIsImhyZWYiLCJwcm90IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZSIsImluZGV4T2YiLCJyZXNvbHZlVXJsIiwiZW5jb2RlVVJJIiwiYmFzZVVybHMiLCJqdXN0RG9tYWluIiwicHJvdG9jb2wiLCJkb21haW4iLCJydHJpbSIsInJlbGF0aXZlQmFzZSIsIm5vb3BUZXN0IiwiZXhlYyIsInNwbGl0Q2VsbHMiLCJ0YWJsZVJvdyIsImNvdW50Iiwicm93IiwibWF0Y2giLCJvZmZzZXQiLCJzdHIiLCJlc2NhcGVkIiwiY3VyciIsImNlbGxzIiwic3BsaXQiLCJ0cmltIiwic2hpZnQiLCJwb3AiLCJzcGxpY2UiLCJwdXNoIiwiYyIsImludmVydCIsImwiLCJzdWZmTGVuIiwiY3VyckNoYXIiLCJmaW5kQ2xvc2luZ0JyYWNrZXQiLCJiIiwibGV2ZWwiLCJjaGVja1Nhbml0aXplRGVwcmVjYXRpb24iLCJjb25zb2xlIiwid2FybiIsInJlcGVhdFN0cmluZyIsInBhdHRlcm4iLCJyZXN1bHQiLCJvdXRwdXRMaW5rIiwiY2FwIiwibGluayIsInJhdyIsImxleGVyIiwidGl0bGUiLCJ0ZXh0Iiwic3RhdGUiLCJpbkxpbmsiLCJ0b2tlbiIsInR5cGUiLCJ0b2tlbnMiLCJpbmxpbmVUb2tlbnMiLCJpbmRlbnRDb2RlQ29tcGVuc2F0aW9uIiwibWF0Y2hJbmRlbnRUb0NvZGUiLCJpbmRlbnRUb0NvZGUiLCJtYXAiLCJub2RlIiwibWF0Y2hJbmRlbnRJbk5vZGUiLCJpbmRlbnRJbk5vZGUiLCJqb2luIiwiVG9rZW5pemVyIiwib3B0aW9ucyIsIl9wcm90byIsInNwYWNlIiwic3JjIiwicnVsZXMiLCJibG9jayIsIm5ld2xpbmUiLCJjb2RlIiwiY29kZUJsb2NrU3R5bGUiLCJmZW5jZXMiLCJsYW5nIiwiaW5saW5lIiwiX2VzY2FwZXMiLCJoZWFkaW5nIiwidHJpbW1lZCIsImRlcHRoIiwiaHIiLCJibG9ja3F1b3RlIiwidG9wIiwiYmxvY2tUb2tlbnMiLCJsaXN0IiwiaXN0YXNrIiwiaXNjaGVja2VkIiwiaW5kZW50IiwiYmxhbmtMaW5lIiwiZW5kc1dpdGhCbGFua0xpbmUiLCJsaW5lIiwibmV4dExpbmUiLCJyYXdMaW5lIiwiaXRlbUNvbnRlbnRzIiwiZW5kRWFybHkiLCJidWxsIiwiaXNvcmRlcmVkIiwib3JkZXJlZCIsInN0YXJ0IiwibG9vc2UiLCJpdGVtcyIsIml0ZW1SZWdleCIsInQiLCJyZXBlYXQiLCJ0cmltTGVmdCIsInNlYXJjaCIsIm5leHRCdWxsZXRSZWdleCIsIk1hdGgiLCJtaW4iLCJoclJlZ2V4IiwiZmVuY2VzQmVnaW5SZWdleCIsImhlYWRpbmdCZWdpblJlZ2V4IiwidGFzayIsImNoZWNrZWQiLCJ0cmltUmlnaHQiLCJzcGFjZXJzIiwiZmlsdGVyIiwiaGFzTXVsdGlwbGVMaW5lQnJlYWtzIiwic29tZSIsInByZSIsImRlZiIsInRhZyIsInRhYmxlIiwiaXRlbSIsImhlYWRlciIsImFsaWduIiwicm93cyIsImoiLCJrIiwibGhlYWRpbmciLCJwYXJhZ3JhcGgiLCJlc2NhcGUkMSIsImluUmF3QmxvY2siLCJ0cmltbWVkVXJsIiwicnRyaW1TbGFzaCIsImxhc3RQYXJlbkluZGV4IiwibGlua0xlbiIsInJlZmxpbmsiLCJsaW5rcyIsIm5vbGluayIsImVtU3Ryb25nIiwibWFza2VkU3JjIiwicHJldkNoYXIiLCJsRGVsaW0iLCJuZXh0Q2hhciIsInB1bmN0dWF0aW9uIiwibExlbmd0aCIsInJEZWxpbSIsInJMZW5ndGgiLCJkZWxpbVRvdGFsIiwibWlkRGVsaW1Ub3RhbCIsImVuZFJlZyIsInJEZWxpbUFzdCIsInJEZWxpbVVuZCIsImxhc3RJbmRleCIsImluZGV4IiwiX3RleHQiLCJjb2Rlc3BhbiIsImhhc05vblNwYWNlQ2hhcnMiLCJoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyIsImJyIiwiZGVsIiwiYXV0b2xpbmsiLCJ1cmwiLCJwcmV2Q2FwWmVybyIsIl9iYWNrcGVkYWwiLCJpbmxpbmVUZXh0IiwiX3BhcmFncmFwaCIsIl9sYWJlbCIsIl90aXRsZSIsImJ1bGxldCIsImxpc3RJdGVtU3RhcnQiLCJfdGFnIiwiX2NvbW1lbnQiLCJub3JtYWwiLCJyZWZsaW5rU2VhcmNoIiwiX3B1bmN0dWF0aW9uIiwiYmxvY2tTa2lwIiwiZXNjYXBlZEVtU3QiLCJfc2NoZW1lIiwiX2VtYWlsIiwiX2F0dHJpYnV0ZSIsIl9ocmVmIiwic3Ryb25nIiwibWlkZGxlIiwiZW5kQXN0IiwiZW5kVW5kIiwiZW0iLCJfZXh0ZW5kZWRfZW1haWwiLCJvdXQiLCJjaGFyQ29kZUF0IiwicmFuZG9tIiwiTGV4ZXIiLCJjcmVhdGUiLCJpbmxpbmVRdWV1ZSIsImxleCIsImxleElubGluZSIsIl90aGlzIiwibGVhZGluZyIsInRhYnMiLCJsYXN0VG9rZW4iLCJjdXRTcmMiLCJsYXN0UGFyYWdyYXBoQ2xpcHBlZCIsImV4dFRva2VuaXplciIsInN0YXJ0QmxvY2siLCJzdGFydEluZGV4IiwiSW5maW5pdHkiLCJ0ZW1wU3JjIiwidGVtcFN0YXJ0IiwiZm9yRWFjaCIsImdldFN0YXJ0SW5kZXgiLCJlcnJNc2ciLCJlcnJvciIsIkVycm9yIiwiX3RoaXMyIiwia2VlcFByZXZDaGFyIiwia2V5cyIsImluY2x1ZGVzIiwibGFzdEluZGV4T2YiLCJzdGFydElubGluZSIsImdldCIsIlJlbmRlcmVyIiwiX2NvZGUiLCJpbmZvc3RyaW5nIiwicXVvdGUiLCJfaHRtbCIsInNsdWdnZXIiLCJpZCIsInNsdWciLCJib2R5Iiwic3RhcnRhdHQiLCJsaXN0aXRlbSIsImNoZWNrYm94IiwidGFibGVyb3ciLCJjb250ZW50IiwidGFibGVjZWxsIiwiZmxhZ3MiLCJpbWFnZSIsIlRleHRSZW5kZXJlciIsIlNsdWdnZXIiLCJzZWVuIiwic2VyaWFsaXplIiwiZ2V0TmV4dFNhZmVTbHVnIiwib3JpZ2luYWxTbHVnIiwiaXNEcnlSdW4iLCJvY2N1cmVuY2VBY2N1bXVsYXRvciIsImRyeXJ1biIsIlBhcnNlciIsInRleHRSZW5kZXJlciIsInBhcnNlIiwicGFyc2VyIiwicGFyc2VJbmxpbmUiLCJsMiIsImwzIiwiY2VsbCIsIml0ZW1Cb2R5IiwicmV0IiwicmVuZGVyZXJzIiwidW5zaGlmdCIsIkhvb2tzIiwicHJlcHJvY2VzcyIsIm1hcmtkb3duIiwicG9zdHByb2Nlc3MiLCJwYXNzVGhyb3VnaEhvb2tzIiwiU2V0Iiwib25FcnJvciIsImNhbGxiYWNrIiwibWVzc2FnZSIsIm1zZyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicGFyc2VNYXJrZG93biIsIm9yaWdPcHQiLCJtYXJrZWQiLCJ0aHJvd0Vycm9yIiwiZXJyIiwicGVuZGluZyIsInNldFRpbWVvdXQiLCJ0aGVuIiwiYWxsIiwiX3Rva2VucyIsInNldE9wdGlvbnMiLCJ1c2UiLCJjaGlsZFRva2VucyIsIl9sZW4iLCJhcmdzIiwiX2tleSIsInBhY2siLCJvcHRzIiwiZXh0IiwicHJldlJlbmRlcmVyIiwiX2xlbjIiLCJfa2V5MiIsIl9sb29wIiwicHJvcCIsIl9sZW4zIiwiX2tleTMiLCJfbG9vcDIiLCJwcmV2VG9rZW5pemVyIiwiX2xlbjQiLCJfa2V5NCIsIl9sb29wMyIsInByZXZIb29rIiwiaGFzIiwiX2xlbjUiLCJfa2V5NSIsIl93YWxrVG9rZW5zIiwidmFsdWVzIiwiY29uY2F0IiwiX2xvb3A0IiwiX3N0ZXAiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsIl9pdGVyYXRvcjQiLCJfc3RlcDQiLCJfY2VsbCIsIl9pdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/marked/lib/marked.cjs\n");

/***/ })

};
;